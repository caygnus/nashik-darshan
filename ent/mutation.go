// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/omkar273/nashikdarshan/ent/category"
	"github.com/omkar273/nashikdarshan/ent/hotel"
	"github.com/omkar273/nashikdarshan/ent/place"
	"github.com/omkar273/nashikdarshan/ent/placeimage"
	"github.com/omkar273/nashikdarshan/ent/predicate"
	"github.com/omkar273/nashikdarshan/ent/review"
	"github.com/omkar273/nashikdarshan/ent/user"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCategory   = "Category"
	TypeHotel      = "Hotel"
	TypePlace      = "Place"
	TypePlaceImage = "PlaceImage"
	TypeReview     = "Review"
	TypeUser       = "User"
)

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	status        *string
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	metadata      *map[string]string
	name          *string
	slug          *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Category, error)
	predicates    []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id string) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *CategoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CategoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CategoryMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *CategoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CategoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CategoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[category.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CategoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[category.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CategoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, category.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CategoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CategoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *CategoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[category.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *CategoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[category.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CategoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, category.FieldUpdatedBy)
}

// SetMetadata sets the "metadata" field.
func (m *CategoryMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CategoryMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CategoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[category.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CategoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[category.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CategoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, category.FieldMetadata)
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.status != nil {
		fields = append(fields, category.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, category.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, category.FieldUpdatedBy)
	}
	if m.metadata != nil {
		fields = append(fields, category.FieldMetadata)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldStatus:
		return m.Status()
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldCreatedBy:
		return m.CreatedBy()
	case category.FieldUpdatedBy:
		return m.UpdatedBy()
	case category.FieldMetadata:
		return m.Metadata()
	case category.FieldName:
		return m.Name()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldStatus:
		return m.OldStatus(ctx)
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case category.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case category.FieldMetadata:
		return m.OldMetadata(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case category.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case category.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldCreatedBy) {
		fields = append(fields, category.FieldCreatedBy)
	}
	if m.FieldCleared(category.FieldUpdatedBy) {
		fields = append(fields, category.FieldUpdatedBy)
	}
	if m.FieldCleared(category.FieldMetadata) {
		fields = append(fields, category.FieldMetadata)
	}
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case category.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case category.FieldMetadata:
		m.ClearMetadata()
		return nil
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldStatus:
		m.ResetStatus()
		return nil
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case category.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case category.FieldMetadata:
		m.ResetMetadata()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Category edge %s", name)
}

// HotelMutation represents an operation that mutates the Hotel nodes in the graph.
type HotelMutation struct {
	config
	op                Op
	typ               string
	id                *string
	status            *string
	created_at        *time.Time
	updated_at        *time.Time
	created_by        *string
	updated_by        *string
	metadata          *map[string]string
	slug              *string
	name              *string
	description       *string
	star_rating       *int
	addstar_rating    *int
	room_count        *int
	addroom_count     *int
	check_in_time     *time.Time
	check_out_time    *time.Time
	address           *map[string]string
	latitude          *decimal.Decimal
	longitude         *decimal.Decimal
	phone             *string
	email             *string
	website           *string
	primary_image_url *string
	thumbnail_url     *string
	price_min         *decimal.Decimal
	price_max         *decimal.Decimal
	currency          *string
	view_count        *int
	addview_count     *int
	rating_avg        *decimal.Decimal
	rating_count      *int
	addrating_count   *int
	last_viewed_at    *time.Time
	popularity_score  *decimal.Decimal
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Hotel, error)
	predicates        []predicate.Hotel
}

var _ ent.Mutation = (*HotelMutation)(nil)

// hotelOption allows management of the mutation configuration using functional options.
type hotelOption func(*HotelMutation)

// newHotelMutation creates new mutation for the Hotel entity.
func newHotelMutation(c config, op Op, opts ...hotelOption) *HotelMutation {
	m := &HotelMutation{
		config:        c,
		op:            op,
		typ:           TypeHotel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHotelID sets the ID field of the mutation.
func withHotelID(id string) hotelOption {
	return func(m *HotelMutation) {
		var (
			err   error
			once  sync.Once
			value *Hotel
		)
		m.oldValue = func(ctx context.Context) (*Hotel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hotel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHotel sets the old Hotel of the mutation.
func withHotel(node *Hotel) hotelOption {
	return func(m *HotelMutation) {
		m.oldValue = func(context.Context) (*Hotel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HotelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HotelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Hotel entities.
func (m *HotelMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HotelMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HotelMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hotel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *HotelMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *HotelMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HotelMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HotelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HotelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HotelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HotelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HotelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HotelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *HotelMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HotelMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *HotelMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[hotel.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *HotelMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[hotel.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HotelMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, hotel.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *HotelMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *HotelMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *HotelMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[hotel.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *HotelMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[hotel.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *HotelMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, hotel.FieldUpdatedBy)
}

// SetMetadata sets the "metadata" field.
func (m *HotelMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *HotelMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *HotelMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[hotel.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *HotelMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[hotel.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *HotelMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, hotel.FieldMetadata)
}

// SetSlug sets the "slug" field.
func (m *HotelMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *HotelMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *HotelMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *HotelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HotelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HotelMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *HotelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HotelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *HotelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[hotel.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *HotelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[hotel.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *HotelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, hotel.FieldDescription)
}

// SetStarRating sets the "star_rating" field.
func (m *HotelMutation) SetStarRating(i int) {
	m.star_rating = &i
	m.addstar_rating = nil
}

// StarRating returns the value of the "star_rating" field in the mutation.
func (m *HotelMutation) StarRating() (r int, exists bool) {
	v := m.star_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldStarRating returns the old "star_rating" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldStarRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarRating: %w", err)
	}
	return oldValue.StarRating, nil
}

// AddStarRating adds i to the "star_rating" field.
func (m *HotelMutation) AddStarRating(i int) {
	if m.addstar_rating != nil {
		*m.addstar_rating += i
	} else {
		m.addstar_rating = &i
	}
}

// AddedStarRating returns the value that was added to the "star_rating" field in this mutation.
func (m *HotelMutation) AddedStarRating() (r int, exists bool) {
	v := m.addstar_rating
	if v == nil {
		return
	}
	return *v, true
}

// ResetStarRating resets all changes to the "star_rating" field.
func (m *HotelMutation) ResetStarRating() {
	m.star_rating = nil
	m.addstar_rating = nil
}

// SetRoomCount sets the "room_count" field.
func (m *HotelMutation) SetRoomCount(i int) {
	m.room_count = &i
	m.addroom_count = nil
}

// RoomCount returns the value of the "room_count" field in the mutation.
func (m *HotelMutation) RoomCount() (r int, exists bool) {
	v := m.room_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomCount returns the old "room_count" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldRoomCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomCount: %w", err)
	}
	return oldValue.RoomCount, nil
}

// AddRoomCount adds i to the "room_count" field.
func (m *HotelMutation) AddRoomCount(i int) {
	if m.addroom_count != nil {
		*m.addroom_count += i
	} else {
		m.addroom_count = &i
	}
}

// AddedRoomCount returns the value that was added to the "room_count" field in this mutation.
func (m *HotelMutation) AddedRoomCount() (r int, exists bool) {
	v := m.addroom_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoomCount resets all changes to the "room_count" field.
func (m *HotelMutation) ResetRoomCount() {
	m.room_count = nil
	m.addroom_count = nil
}

// SetCheckInTime sets the "check_in_time" field.
func (m *HotelMutation) SetCheckInTime(t time.Time) {
	m.check_in_time = &t
}

// CheckInTime returns the value of the "check_in_time" field in the mutation.
func (m *HotelMutation) CheckInTime() (r time.Time, exists bool) {
	v := m.check_in_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckInTime returns the old "check_in_time" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldCheckInTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckInTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckInTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckInTime: %w", err)
	}
	return oldValue.CheckInTime, nil
}

// ClearCheckInTime clears the value of the "check_in_time" field.
func (m *HotelMutation) ClearCheckInTime() {
	m.check_in_time = nil
	m.clearedFields[hotel.FieldCheckInTime] = struct{}{}
}

// CheckInTimeCleared returns if the "check_in_time" field was cleared in this mutation.
func (m *HotelMutation) CheckInTimeCleared() bool {
	_, ok := m.clearedFields[hotel.FieldCheckInTime]
	return ok
}

// ResetCheckInTime resets all changes to the "check_in_time" field.
func (m *HotelMutation) ResetCheckInTime() {
	m.check_in_time = nil
	delete(m.clearedFields, hotel.FieldCheckInTime)
}

// SetCheckOutTime sets the "check_out_time" field.
func (m *HotelMutation) SetCheckOutTime(t time.Time) {
	m.check_out_time = &t
}

// CheckOutTime returns the value of the "check_out_time" field in the mutation.
func (m *HotelMutation) CheckOutTime() (r time.Time, exists bool) {
	v := m.check_out_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckOutTime returns the old "check_out_time" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldCheckOutTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckOutTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckOutTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckOutTime: %w", err)
	}
	return oldValue.CheckOutTime, nil
}

// ClearCheckOutTime clears the value of the "check_out_time" field.
func (m *HotelMutation) ClearCheckOutTime() {
	m.check_out_time = nil
	m.clearedFields[hotel.FieldCheckOutTime] = struct{}{}
}

// CheckOutTimeCleared returns if the "check_out_time" field was cleared in this mutation.
func (m *HotelMutation) CheckOutTimeCleared() bool {
	_, ok := m.clearedFields[hotel.FieldCheckOutTime]
	return ok
}

// ResetCheckOutTime resets all changes to the "check_out_time" field.
func (m *HotelMutation) ResetCheckOutTime() {
	m.check_out_time = nil
	delete(m.clearedFields, hotel.FieldCheckOutTime)
}

// SetAddress sets the "address" field.
func (m *HotelMutation) SetAddress(value map[string]string) {
	m.address = &value
}

// Address returns the value of the "address" field in the mutation.
func (m *HotelMutation) Address() (r map[string]string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldAddress(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *HotelMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[hotel.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *HotelMutation) AddressCleared() bool {
	_, ok := m.clearedFields[hotel.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *HotelMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, hotel.FieldAddress)
}

// SetLatitude sets the "latitude" field.
func (m *HotelMutation) SetLatitude(d decimal.Decimal) {
	m.latitude = &d
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *HotelMutation) Latitude() (r decimal.Decimal, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldLatitude(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *HotelMutation) ResetLatitude() {
	m.latitude = nil
}

// SetLongitude sets the "longitude" field.
func (m *HotelMutation) SetLongitude(d decimal.Decimal) {
	m.longitude = &d
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *HotelMutation) Longitude() (r decimal.Decimal, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldLongitude(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *HotelMutation) ResetLongitude() {
	m.longitude = nil
}

// SetPhone sets the "phone" field.
func (m *HotelMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *HotelMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *HotelMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[hotel.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *HotelMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[hotel.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *HotelMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, hotel.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *HotelMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *HotelMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *HotelMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[hotel.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *HotelMutation) EmailCleared() bool {
	_, ok := m.clearedFields[hotel.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *HotelMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, hotel.FieldEmail)
}

// SetWebsite sets the "website" field.
func (m *HotelMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *HotelMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *HotelMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[hotel.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *HotelMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[hotel.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *HotelMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, hotel.FieldWebsite)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *HotelMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *HotelMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *HotelMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[hotel.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *HotelMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[hotel.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *HotelMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, hotel.FieldPrimaryImageURL)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *HotelMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *HotelMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *HotelMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[hotel.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *HotelMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[hotel.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *HotelMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, hotel.FieldThumbnailURL)
}

// SetPriceMin sets the "price_min" field.
func (m *HotelMutation) SetPriceMin(d decimal.Decimal) {
	m.price_min = &d
}

// PriceMin returns the value of the "price_min" field in the mutation.
func (m *HotelMutation) PriceMin() (r decimal.Decimal, exists bool) {
	v := m.price_min
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceMin returns the old "price_min" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldPriceMin(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceMin: %w", err)
	}
	return oldValue.PriceMin, nil
}

// ClearPriceMin clears the value of the "price_min" field.
func (m *HotelMutation) ClearPriceMin() {
	m.price_min = nil
	m.clearedFields[hotel.FieldPriceMin] = struct{}{}
}

// PriceMinCleared returns if the "price_min" field was cleared in this mutation.
func (m *HotelMutation) PriceMinCleared() bool {
	_, ok := m.clearedFields[hotel.FieldPriceMin]
	return ok
}

// ResetPriceMin resets all changes to the "price_min" field.
func (m *HotelMutation) ResetPriceMin() {
	m.price_min = nil
	delete(m.clearedFields, hotel.FieldPriceMin)
}

// SetPriceMax sets the "price_max" field.
func (m *HotelMutation) SetPriceMax(d decimal.Decimal) {
	m.price_max = &d
}

// PriceMax returns the value of the "price_max" field in the mutation.
func (m *HotelMutation) PriceMax() (r decimal.Decimal, exists bool) {
	v := m.price_max
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceMax returns the old "price_max" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldPriceMax(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceMax: %w", err)
	}
	return oldValue.PriceMax, nil
}

// ClearPriceMax clears the value of the "price_max" field.
func (m *HotelMutation) ClearPriceMax() {
	m.price_max = nil
	m.clearedFields[hotel.FieldPriceMax] = struct{}{}
}

// PriceMaxCleared returns if the "price_max" field was cleared in this mutation.
func (m *HotelMutation) PriceMaxCleared() bool {
	_, ok := m.clearedFields[hotel.FieldPriceMax]
	return ok
}

// ResetPriceMax resets all changes to the "price_max" field.
func (m *HotelMutation) ResetPriceMax() {
	m.price_max = nil
	delete(m.clearedFields, hotel.FieldPriceMax)
}

// SetCurrency sets the "currency" field.
func (m *HotelMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *HotelMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *HotelMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[hotel.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *HotelMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[hotel.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *HotelMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, hotel.FieldCurrency)
}

// SetViewCount sets the "view_count" field.
func (m *HotelMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *HotelMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *HotelMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *HotelMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *HotelMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetRatingAvg sets the "rating_avg" field.
func (m *HotelMutation) SetRatingAvg(d decimal.Decimal) {
	m.rating_avg = &d
}

// RatingAvg returns the value of the "rating_avg" field in the mutation.
func (m *HotelMutation) RatingAvg() (r decimal.Decimal, exists bool) {
	v := m.rating_avg
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingAvg returns the old "rating_avg" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldRatingAvg(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingAvg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingAvg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingAvg: %w", err)
	}
	return oldValue.RatingAvg, nil
}

// ResetRatingAvg resets all changes to the "rating_avg" field.
func (m *HotelMutation) ResetRatingAvg() {
	m.rating_avg = nil
}

// SetRatingCount sets the "rating_count" field.
func (m *HotelMutation) SetRatingCount(i int) {
	m.rating_count = &i
	m.addrating_count = nil
}

// RatingCount returns the value of the "rating_count" field in the mutation.
func (m *HotelMutation) RatingCount() (r int, exists bool) {
	v := m.rating_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingCount returns the old "rating_count" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldRatingCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingCount: %w", err)
	}
	return oldValue.RatingCount, nil
}

// AddRatingCount adds i to the "rating_count" field.
func (m *HotelMutation) AddRatingCount(i int) {
	if m.addrating_count != nil {
		*m.addrating_count += i
	} else {
		m.addrating_count = &i
	}
}

// AddedRatingCount returns the value that was added to the "rating_count" field in this mutation.
func (m *HotelMutation) AddedRatingCount() (r int, exists bool) {
	v := m.addrating_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatingCount resets all changes to the "rating_count" field.
func (m *HotelMutation) ResetRatingCount() {
	m.rating_count = nil
	m.addrating_count = nil
}

// SetLastViewedAt sets the "last_viewed_at" field.
func (m *HotelMutation) SetLastViewedAt(t time.Time) {
	m.last_viewed_at = &t
}

// LastViewedAt returns the value of the "last_viewed_at" field in the mutation.
func (m *HotelMutation) LastViewedAt() (r time.Time, exists bool) {
	v := m.last_viewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastViewedAt returns the old "last_viewed_at" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldLastViewedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastViewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastViewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastViewedAt: %w", err)
	}
	return oldValue.LastViewedAt, nil
}

// ClearLastViewedAt clears the value of the "last_viewed_at" field.
func (m *HotelMutation) ClearLastViewedAt() {
	m.last_viewed_at = nil
	m.clearedFields[hotel.FieldLastViewedAt] = struct{}{}
}

// LastViewedAtCleared returns if the "last_viewed_at" field was cleared in this mutation.
func (m *HotelMutation) LastViewedAtCleared() bool {
	_, ok := m.clearedFields[hotel.FieldLastViewedAt]
	return ok
}

// ResetLastViewedAt resets all changes to the "last_viewed_at" field.
func (m *HotelMutation) ResetLastViewedAt() {
	m.last_viewed_at = nil
	delete(m.clearedFields, hotel.FieldLastViewedAt)
}

// SetPopularityScore sets the "popularity_score" field.
func (m *HotelMutation) SetPopularityScore(d decimal.Decimal) {
	m.popularity_score = &d
}

// PopularityScore returns the value of the "popularity_score" field in the mutation.
func (m *HotelMutation) PopularityScore() (r decimal.Decimal, exists bool) {
	v := m.popularity_score
	if v == nil {
		return
	}
	return *v, true
}

// OldPopularityScore returns the old "popularity_score" field's value of the Hotel entity.
// If the Hotel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotelMutation) OldPopularityScore(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopularityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopularityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopularityScore: %w", err)
	}
	return oldValue.PopularityScore, nil
}

// ResetPopularityScore resets all changes to the "popularity_score" field.
func (m *HotelMutation) ResetPopularityScore() {
	m.popularity_score = nil
}

// Where appends a list predicates to the HotelMutation builder.
func (m *HotelMutation) Where(ps ...predicate.Hotel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HotelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HotelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Hotel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HotelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HotelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Hotel).
func (m *HotelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HotelMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.status != nil {
		fields = append(fields, hotel.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, hotel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hotel.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, hotel.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, hotel.FieldUpdatedBy)
	}
	if m.metadata != nil {
		fields = append(fields, hotel.FieldMetadata)
	}
	if m.slug != nil {
		fields = append(fields, hotel.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, hotel.FieldName)
	}
	if m.description != nil {
		fields = append(fields, hotel.FieldDescription)
	}
	if m.star_rating != nil {
		fields = append(fields, hotel.FieldStarRating)
	}
	if m.room_count != nil {
		fields = append(fields, hotel.FieldRoomCount)
	}
	if m.check_in_time != nil {
		fields = append(fields, hotel.FieldCheckInTime)
	}
	if m.check_out_time != nil {
		fields = append(fields, hotel.FieldCheckOutTime)
	}
	if m.address != nil {
		fields = append(fields, hotel.FieldAddress)
	}
	if m.latitude != nil {
		fields = append(fields, hotel.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, hotel.FieldLongitude)
	}
	if m.phone != nil {
		fields = append(fields, hotel.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, hotel.FieldEmail)
	}
	if m.website != nil {
		fields = append(fields, hotel.FieldWebsite)
	}
	if m.primary_image_url != nil {
		fields = append(fields, hotel.FieldPrimaryImageURL)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, hotel.FieldThumbnailURL)
	}
	if m.price_min != nil {
		fields = append(fields, hotel.FieldPriceMin)
	}
	if m.price_max != nil {
		fields = append(fields, hotel.FieldPriceMax)
	}
	if m.currency != nil {
		fields = append(fields, hotel.FieldCurrency)
	}
	if m.view_count != nil {
		fields = append(fields, hotel.FieldViewCount)
	}
	if m.rating_avg != nil {
		fields = append(fields, hotel.FieldRatingAvg)
	}
	if m.rating_count != nil {
		fields = append(fields, hotel.FieldRatingCount)
	}
	if m.last_viewed_at != nil {
		fields = append(fields, hotel.FieldLastViewedAt)
	}
	if m.popularity_score != nil {
		fields = append(fields, hotel.FieldPopularityScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HotelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hotel.FieldStatus:
		return m.Status()
	case hotel.FieldCreatedAt:
		return m.CreatedAt()
	case hotel.FieldUpdatedAt:
		return m.UpdatedAt()
	case hotel.FieldCreatedBy:
		return m.CreatedBy()
	case hotel.FieldUpdatedBy:
		return m.UpdatedBy()
	case hotel.FieldMetadata:
		return m.Metadata()
	case hotel.FieldSlug:
		return m.Slug()
	case hotel.FieldName:
		return m.Name()
	case hotel.FieldDescription:
		return m.Description()
	case hotel.FieldStarRating:
		return m.StarRating()
	case hotel.FieldRoomCount:
		return m.RoomCount()
	case hotel.FieldCheckInTime:
		return m.CheckInTime()
	case hotel.FieldCheckOutTime:
		return m.CheckOutTime()
	case hotel.FieldAddress:
		return m.Address()
	case hotel.FieldLatitude:
		return m.Latitude()
	case hotel.FieldLongitude:
		return m.Longitude()
	case hotel.FieldPhone:
		return m.Phone()
	case hotel.FieldEmail:
		return m.Email()
	case hotel.FieldWebsite:
		return m.Website()
	case hotel.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case hotel.FieldThumbnailURL:
		return m.ThumbnailURL()
	case hotel.FieldPriceMin:
		return m.PriceMin()
	case hotel.FieldPriceMax:
		return m.PriceMax()
	case hotel.FieldCurrency:
		return m.Currency()
	case hotel.FieldViewCount:
		return m.ViewCount()
	case hotel.FieldRatingAvg:
		return m.RatingAvg()
	case hotel.FieldRatingCount:
		return m.RatingCount()
	case hotel.FieldLastViewedAt:
		return m.LastViewedAt()
	case hotel.FieldPopularityScore:
		return m.PopularityScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HotelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hotel.FieldStatus:
		return m.OldStatus(ctx)
	case hotel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hotel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hotel.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case hotel.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case hotel.FieldMetadata:
		return m.OldMetadata(ctx)
	case hotel.FieldSlug:
		return m.OldSlug(ctx)
	case hotel.FieldName:
		return m.OldName(ctx)
	case hotel.FieldDescription:
		return m.OldDescription(ctx)
	case hotel.FieldStarRating:
		return m.OldStarRating(ctx)
	case hotel.FieldRoomCount:
		return m.OldRoomCount(ctx)
	case hotel.FieldCheckInTime:
		return m.OldCheckInTime(ctx)
	case hotel.FieldCheckOutTime:
		return m.OldCheckOutTime(ctx)
	case hotel.FieldAddress:
		return m.OldAddress(ctx)
	case hotel.FieldLatitude:
		return m.OldLatitude(ctx)
	case hotel.FieldLongitude:
		return m.OldLongitude(ctx)
	case hotel.FieldPhone:
		return m.OldPhone(ctx)
	case hotel.FieldEmail:
		return m.OldEmail(ctx)
	case hotel.FieldWebsite:
		return m.OldWebsite(ctx)
	case hotel.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case hotel.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case hotel.FieldPriceMin:
		return m.OldPriceMin(ctx)
	case hotel.FieldPriceMax:
		return m.OldPriceMax(ctx)
	case hotel.FieldCurrency:
		return m.OldCurrency(ctx)
	case hotel.FieldViewCount:
		return m.OldViewCount(ctx)
	case hotel.FieldRatingAvg:
		return m.OldRatingAvg(ctx)
	case hotel.FieldRatingCount:
		return m.OldRatingCount(ctx)
	case hotel.FieldLastViewedAt:
		return m.OldLastViewedAt(ctx)
	case hotel.FieldPopularityScore:
		return m.OldPopularityScore(ctx)
	}
	return nil, fmt.Errorf("unknown Hotel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HotelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hotel.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case hotel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hotel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hotel.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case hotel.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case hotel.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case hotel.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case hotel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hotel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hotel.FieldStarRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarRating(v)
		return nil
	case hotel.FieldRoomCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomCount(v)
		return nil
	case hotel.FieldCheckInTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckInTime(v)
		return nil
	case hotel.FieldCheckOutTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckOutTime(v)
		return nil
	case hotel.FieldAddress:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case hotel.FieldLatitude:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case hotel.FieldLongitude:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case hotel.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case hotel.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case hotel.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case hotel.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case hotel.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case hotel.FieldPriceMin:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceMin(v)
		return nil
	case hotel.FieldPriceMax:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceMax(v)
		return nil
	case hotel.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case hotel.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case hotel.FieldRatingAvg:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingAvg(v)
		return nil
	case hotel.FieldRatingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingCount(v)
		return nil
	case hotel.FieldLastViewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastViewedAt(v)
		return nil
	case hotel.FieldPopularityScore:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopularityScore(v)
		return nil
	}
	return fmt.Errorf("unknown Hotel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HotelMutation) AddedFields() []string {
	var fields []string
	if m.addstar_rating != nil {
		fields = append(fields, hotel.FieldStarRating)
	}
	if m.addroom_count != nil {
		fields = append(fields, hotel.FieldRoomCount)
	}
	if m.addview_count != nil {
		fields = append(fields, hotel.FieldViewCount)
	}
	if m.addrating_count != nil {
		fields = append(fields, hotel.FieldRatingCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HotelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hotel.FieldStarRating:
		return m.AddedStarRating()
	case hotel.FieldRoomCount:
		return m.AddedRoomCount()
	case hotel.FieldViewCount:
		return m.AddedViewCount()
	case hotel.FieldRatingCount:
		return m.AddedRatingCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HotelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hotel.FieldStarRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStarRating(v)
		return nil
	case hotel.FieldRoomCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoomCount(v)
		return nil
	case hotel.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case hotel.FieldRatingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatingCount(v)
		return nil
	}
	return fmt.Errorf("unknown Hotel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HotelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hotel.FieldCreatedBy) {
		fields = append(fields, hotel.FieldCreatedBy)
	}
	if m.FieldCleared(hotel.FieldUpdatedBy) {
		fields = append(fields, hotel.FieldUpdatedBy)
	}
	if m.FieldCleared(hotel.FieldMetadata) {
		fields = append(fields, hotel.FieldMetadata)
	}
	if m.FieldCleared(hotel.FieldDescription) {
		fields = append(fields, hotel.FieldDescription)
	}
	if m.FieldCleared(hotel.FieldCheckInTime) {
		fields = append(fields, hotel.FieldCheckInTime)
	}
	if m.FieldCleared(hotel.FieldCheckOutTime) {
		fields = append(fields, hotel.FieldCheckOutTime)
	}
	if m.FieldCleared(hotel.FieldAddress) {
		fields = append(fields, hotel.FieldAddress)
	}
	if m.FieldCleared(hotel.FieldPhone) {
		fields = append(fields, hotel.FieldPhone)
	}
	if m.FieldCleared(hotel.FieldEmail) {
		fields = append(fields, hotel.FieldEmail)
	}
	if m.FieldCleared(hotel.FieldWebsite) {
		fields = append(fields, hotel.FieldWebsite)
	}
	if m.FieldCleared(hotel.FieldPrimaryImageURL) {
		fields = append(fields, hotel.FieldPrimaryImageURL)
	}
	if m.FieldCleared(hotel.FieldThumbnailURL) {
		fields = append(fields, hotel.FieldThumbnailURL)
	}
	if m.FieldCleared(hotel.FieldPriceMin) {
		fields = append(fields, hotel.FieldPriceMin)
	}
	if m.FieldCleared(hotel.FieldPriceMax) {
		fields = append(fields, hotel.FieldPriceMax)
	}
	if m.FieldCleared(hotel.FieldCurrency) {
		fields = append(fields, hotel.FieldCurrency)
	}
	if m.FieldCleared(hotel.FieldLastViewedAt) {
		fields = append(fields, hotel.FieldLastViewedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HotelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HotelMutation) ClearField(name string) error {
	switch name {
	case hotel.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case hotel.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case hotel.FieldMetadata:
		m.ClearMetadata()
		return nil
	case hotel.FieldDescription:
		m.ClearDescription()
		return nil
	case hotel.FieldCheckInTime:
		m.ClearCheckInTime()
		return nil
	case hotel.FieldCheckOutTime:
		m.ClearCheckOutTime()
		return nil
	case hotel.FieldAddress:
		m.ClearAddress()
		return nil
	case hotel.FieldPhone:
		m.ClearPhone()
		return nil
	case hotel.FieldEmail:
		m.ClearEmail()
		return nil
	case hotel.FieldWebsite:
		m.ClearWebsite()
		return nil
	case hotel.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case hotel.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case hotel.FieldPriceMin:
		m.ClearPriceMin()
		return nil
	case hotel.FieldPriceMax:
		m.ClearPriceMax()
		return nil
	case hotel.FieldCurrency:
		m.ClearCurrency()
		return nil
	case hotel.FieldLastViewedAt:
		m.ClearLastViewedAt()
		return nil
	}
	return fmt.Errorf("unknown Hotel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HotelMutation) ResetField(name string) error {
	switch name {
	case hotel.FieldStatus:
		m.ResetStatus()
		return nil
	case hotel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hotel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hotel.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case hotel.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case hotel.FieldMetadata:
		m.ResetMetadata()
		return nil
	case hotel.FieldSlug:
		m.ResetSlug()
		return nil
	case hotel.FieldName:
		m.ResetName()
		return nil
	case hotel.FieldDescription:
		m.ResetDescription()
		return nil
	case hotel.FieldStarRating:
		m.ResetStarRating()
		return nil
	case hotel.FieldRoomCount:
		m.ResetRoomCount()
		return nil
	case hotel.FieldCheckInTime:
		m.ResetCheckInTime()
		return nil
	case hotel.FieldCheckOutTime:
		m.ResetCheckOutTime()
		return nil
	case hotel.FieldAddress:
		m.ResetAddress()
		return nil
	case hotel.FieldLatitude:
		m.ResetLatitude()
		return nil
	case hotel.FieldLongitude:
		m.ResetLongitude()
		return nil
	case hotel.FieldPhone:
		m.ResetPhone()
		return nil
	case hotel.FieldEmail:
		m.ResetEmail()
		return nil
	case hotel.FieldWebsite:
		m.ResetWebsite()
		return nil
	case hotel.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case hotel.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case hotel.FieldPriceMin:
		m.ResetPriceMin()
		return nil
	case hotel.FieldPriceMax:
		m.ResetPriceMax()
		return nil
	case hotel.FieldCurrency:
		m.ResetCurrency()
		return nil
	case hotel.FieldViewCount:
		m.ResetViewCount()
		return nil
	case hotel.FieldRatingAvg:
		m.ResetRatingAvg()
		return nil
	case hotel.FieldRatingCount:
		m.ResetRatingCount()
		return nil
	case hotel.FieldLastViewedAt:
		m.ResetLastViewedAt()
		return nil
	case hotel.FieldPopularityScore:
		m.ResetPopularityScore()
		return nil
	}
	return fmt.Errorf("unknown Hotel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HotelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HotelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HotelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HotelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HotelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HotelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HotelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Hotel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HotelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Hotel edge %s", name)
}

// PlaceMutation represents an operation that mutates the Place nodes in the graph.
type PlaceMutation struct {
	config
	op                Op
	typ               string
	id                *string
	status            *string
	created_at        *time.Time
	updated_at        *time.Time
	created_by        *string
	updated_by        *string
	metadata          *map[string]string
	slug              *string
	title             *string
	subtitle          *string
	short_description *string
	long_description  *string
	place_type        *string
	categories        *[]string
	appendcategories  []string
	address           *map[string]string
	latitude          *decimal.Decimal
	longitude         *decimal.Decimal
	primary_image_url *string
	thumbnail_url     *string
	amenities         *[]string
	appendamenities   []string
	view_count        *int
	addview_count     *int
	rating_avg        *decimal.Decimal
	rating_count      *int
	addrating_count   *int
	last_viewed_at    *time.Time
	popularity_score  *decimal.Decimal
	clearedFields     map[string]struct{}
	images            map[string]struct{}
	removedimages     map[string]struct{}
	clearedimages     bool
	done              bool
	oldValue          func(context.Context) (*Place, error)
	predicates        []predicate.Place
}

var _ ent.Mutation = (*PlaceMutation)(nil)

// placeOption allows management of the mutation configuration using functional options.
type placeOption func(*PlaceMutation)

// newPlaceMutation creates new mutation for the Place entity.
func newPlaceMutation(c config, op Op, opts ...placeOption) *PlaceMutation {
	m := &PlaceMutation{
		config:        c,
		op:            op,
		typ:           TypePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceID sets the ID field of the mutation.
func withPlaceID(id string) placeOption {
	return func(m *PlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Place
		)
		m.oldValue = func(ctx context.Context) (*Place, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Place.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlace sets the old Place of the mutation.
func withPlace(node *Place) placeOption {
	return func(m *PlaceMutation) {
		m.oldValue = func(context.Context) (*Place, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Place entities.
func (m *PlaceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Place.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *PlaceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PlaceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PlaceMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PlaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PlaceMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PlaceMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PlaceMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[place.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PlaceMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[place.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PlaceMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, place.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PlaceMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PlaceMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PlaceMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[place.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PlaceMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[place.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PlaceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, place.FieldUpdatedBy)
}

// SetMetadata sets the "metadata" field.
func (m *PlaceMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PlaceMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PlaceMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[place.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PlaceMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[place.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PlaceMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, place.FieldMetadata)
}

// SetSlug sets the "slug" field.
func (m *PlaceMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PlaceMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *PlaceMutation) ResetSlug() {
	m.slug = nil
}

// SetTitle sets the "title" field.
func (m *PlaceMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PlaceMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PlaceMutation) ResetTitle() {
	m.title = nil
}

// SetSubtitle sets the "subtitle" field.
func (m *PlaceMutation) SetSubtitle(s string) {
	m.subtitle = &s
}

// Subtitle returns the value of the "subtitle" field in the mutation.
func (m *PlaceMutation) Subtitle() (r string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old "subtitle" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldSubtitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ClearSubtitle clears the value of the "subtitle" field.
func (m *PlaceMutation) ClearSubtitle() {
	m.subtitle = nil
	m.clearedFields[place.FieldSubtitle] = struct{}{}
}

// SubtitleCleared returns if the "subtitle" field was cleared in this mutation.
func (m *PlaceMutation) SubtitleCleared() bool {
	_, ok := m.clearedFields[place.FieldSubtitle]
	return ok
}

// ResetSubtitle resets all changes to the "subtitle" field.
func (m *PlaceMutation) ResetSubtitle() {
	m.subtitle = nil
	delete(m.clearedFields, place.FieldSubtitle)
}

// SetShortDescription sets the "short_description" field.
func (m *PlaceMutation) SetShortDescription(s string) {
	m.short_description = &s
}

// ShortDescription returns the value of the "short_description" field in the mutation.
func (m *PlaceMutation) ShortDescription() (r string, exists bool) {
	v := m.short_description
	if v == nil {
		return
	}
	return *v, true
}

// OldShortDescription returns the old "short_description" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldShortDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortDescription: %w", err)
	}
	return oldValue.ShortDescription, nil
}

// ClearShortDescription clears the value of the "short_description" field.
func (m *PlaceMutation) ClearShortDescription() {
	m.short_description = nil
	m.clearedFields[place.FieldShortDescription] = struct{}{}
}

// ShortDescriptionCleared returns if the "short_description" field was cleared in this mutation.
func (m *PlaceMutation) ShortDescriptionCleared() bool {
	_, ok := m.clearedFields[place.FieldShortDescription]
	return ok
}

// ResetShortDescription resets all changes to the "short_description" field.
func (m *PlaceMutation) ResetShortDescription() {
	m.short_description = nil
	delete(m.clearedFields, place.FieldShortDescription)
}

// SetLongDescription sets the "long_description" field.
func (m *PlaceMutation) SetLongDescription(s string) {
	m.long_description = &s
}

// LongDescription returns the value of the "long_description" field in the mutation.
func (m *PlaceMutation) LongDescription() (r string, exists bool) {
	v := m.long_description
	if v == nil {
		return
	}
	return *v, true
}

// OldLongDescription returns the old "long_description" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLongDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongDescription: %w", err)
	}
	return oldValue.LongDescription, nil
}

// ClearLongDescription clears the value of the "long_description" field.
func (m *PlaceMutation) ClearLongDescription() {
	m.long_description = nil
	m.clearedFields[place.FieldLongDescription] = struct{}{}
}

// LongDescriptionCleared returns if the "long_description" field was cleared in this mutation.
func (m *PlaceMutation) LongDescriptionCleared() bool {
	_, ok := m.clearedFields[place.FieldLongDescription]
	return ok
}

// ResetLongDescription resets all changes to the "long_description" field.
func (m *PlaceMutation) ResetLongDescription() {
	m.long_description = nil
	delete(m.clearedFields, place.FieldLongDescription)
}

// SetPlaceType sets the "place_type" field.
func (m *PlaceMutation) SetPlaceType(s string) {
	m.place_type = &s
}

// PlaceType returns the value of the "place_type" field in the mutation.
func (m *PlaceMutation) PlaceType() (r string, exists bool) {
	v := m.place_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceType returns the old "place_type" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldPlaceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceType: %w", err)
	}
	return oldValue.PlaceType, nil
}

// ResetPlaceType resets all changes to the "place_type" field.
func (m *PlaceMutation) ResetPlaceType() {
	m.place_type = nil
}

// SetCategories sets the "categories" field.
func (m *PlaceMutation) SetCategories(s []string) {
	m.categories = &s
	m.appendcategories = nil
}

// Categories returns the value of the "categories" field in the mutation.
func (m *PlaceMutation) Categories() (r []string, exists bool) {
	v := m.categories
	if v == nil {
		return
	}
	return *v, true
}

// OldCategories returns the old "categories" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldCategories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategories: %w", err)
	}
	return oldValue.Categories, nil
}

// AppendCategories adds s to the "categories" field.
func (m *PlaceMutation) AppendCategories(s []string) {
	m.appendcategories = append(m.appendcategories, s...)
}

// AppendedCategories returns the list of values that were appended to the "categories" field in this mutation.
func (m *PlaceMutation) AppendedCategories() ([]string, bool) {
	if len(m.appendcategories) == 0 {
		return nil, false
	}
	return m.appendcategories, true
}

// ClearCategories clears the value of the "categories" field.
func (m *PlaceMutation) ClearCategories() {
	m.categories = nil
	m.appendcategories = nil
	m.clearedFields[place.FieldCategories] = struct{}{}
}

// CategoriesCleared returns if the "categories" field was cleared in this mutation.
func (m *PlaceMutation) CategoriesCleared() bool {
	_, ok := m.clearedFields[place.FieldCategories]
	return ok
}

// ResetCategories resets all changes to the "categories" field.
func (m *PlaceMutation) ResetCategories() {
	m.categories = nil
	m.appendcategories = nil
	delete(m.clearedFields, place.FieldCategories)
}

// SetAddress sets the "address" field.
func (m *PlaceMutation) SetAddress(value map[string]string) {
	m.address = &value
}

// Address returns the value of the "address" field in the mutation.
func (m *PlaceMutation) Address() (r map[string]string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldAddress(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *PlaceMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[place.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *PlaceMutation) AddressCleared() bool {
	_, ok := m.clearedFields[place.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *PlaceMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, place.FieldAddress)
}

// SetLatitude sets the "latitude" field.
func (m *PlaceMutation) SetLatitude(d decimal.Decimal) {
	m.latitude = &d
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *PlaceMutation) Latitude() (r decimal.Decimal, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLatitude(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *PlaceMutation) ResetLatitude() {
	m.latitude = nil
}

// SetLongitude sets the "longitude" field.
func (m *PlaceMutation) SetLongitude(d decimal.Decimal) {
	m.longitude = &d
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *PlaceMutation) Longitude() (r decimal.Decimal, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLongitude(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *PlaceMutation) ResetLongitude() {
	m.longitude = nil
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *PlaceMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *PlaceMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *PlaceMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[place.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *PlaceMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[place.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *PlaceMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, place.FieldPrimaryImageURL)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *PlaceMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *PlaceMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *PlaceMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[place.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *PlaceMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[place.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *PlaceMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, place.FieldThumbnailURL)
}

// SetAmenities sets the "amenities" field.
func (m *PlaceMutation) SetAmenities(s []string) {
	m.amenities = &s
	m.appendamenities = nil
}

// Amenities returns the value of the "amenities" field in the mutation.
func (m *PlaceMutation) Amenities() (r []string, exists bool) {
	v := m.amenities
	if v == nil {
		return
	}
	return *v, true
}

// OldAmenities returns the old "amenities" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldAmenities(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmenities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmenities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmenities: %w", err)
	}
	return oldValue.Amenities, nil
}

// AppendAmenities adds s to the "amenities" field.
func (m *PlaceMutation) AppendAmenities(s []string) {
	m.appendamenities = append(m.appendamenities, s...)
}

// AppendedAmenities returns the list of values that were appended to the "amenities" field in this mutation.
func (m *PlaceMutation) AppendedAmenities() ([]string, bool) {
	if len(m.appendamenities) == 0 {
		return nil, false
	}
	return m.appendamenities, true
}

// ClearAmenities clears the value of the "amenities" field.
func (m *PlaceMutation) ClearAmenities() {
	m.amenities = nil
	m.appendamenities = nil
	m.clearedFields[place.FieldAmenities] = struct{}{}
}

// AmenitiesCleared returns if the "amenities" field was cleared in this mutation.
func (m *PlaceMutation) AmenitiesCleared() bool {
	_, ok := m.clearedFields[place.FieldAmenities]
	return ok
}

// ResetAmenities resets all changes to the "amenities" field.
func (m *PlaceMutation) ResetAmenities() {
	m.amenities = nil
	m.appendamenities = nil
	delete(m.clearedFields, place.FieldAmenities)
}

// SetViewCount sets the "view_count" field.
func (m *PlaceMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *PlaceMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *PlaceMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *PlaceMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *PlaceMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetRatingAvg sets the "rating_avg" field.
func (m *PlaceMutation) SetRatingAvg(d decimal.Decimal) {
	m.rating_avg = &d
}

// RatingAvg returns the value of the "rating_avg" field in the mutation.
func (m *PlaceMutation) RatingAvg() (r decimal.Decimal, exists bool) {
	v := m.rating_avg
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingAvg returns the old "rating_avg" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldRatingAvg(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingAvg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingAvg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingAvg: %w", err)
	}
	return oldValue.RatingAvg, nil
}

// ResetRatingAvg resets all changes to the "rating_avg" field.
func (m *PlaceMutation) ResetRatingAvg() {
	m.rating_avg = nil
}

// SetRatingCount sets the "rating_count" field.
func (m *PlaceMutation) SetRatingCount(i int) {
	m.rating_count = &i
	m.addrating_count = nil
}

// RatingCount returns the value of the "rating_count" field in the mutation.
func (m *PlaceMutation) RatingCount() (r int, exists bool) {
	v := m.rating_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingCount returns the old "rating_count" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldRatingCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingCount: %w", err)
	}
	return oldValue.RatingCount, nil
}

// AddRatingCount adds i to the "rating_count" field.
func (m *PlaceMutation) AddRatingCount(i int) {
	if m.addrating_count != nil {
		*m.addrating_count += i
	} else {
		m.addrating_count = &i
	}
}

// AddedRatingCount returns the value that was added to the "rating_count" field in this mutation.
func (m *PlaceMutation) AddedRatingCount() (r int, exists bool) {
	v := m.addrating_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatingCount resets all changes to the "rating_count" field.
func (m *PlaceMutation) ResetRatingCount() {
	m.rating_count = nil
	m.addrating_count = nil
}

// SetLastViewedAt sets the "last_viewed_at" field.
func (m *PlaceMutation) SetLastViewedAt(t time.Time) {
	m.last_viewed_at = &t
}

// LastViewedAt returns the value of the "last_viewed_at" field in the mutation.
func (m *PlaceMutation) LastViewedAt() (r time.Time, exists bool) {
	v := m.last_viewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastViewedAt returns the old "last_viewed_at" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLastViewedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastViewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastViewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastViewedAt: %w", err)
	}
	return oldValue.LastViewedAt, nil
}

// ClearLastViewedAt clears the value of the "last_viewed_at" field.
func (m *PlaceMutation) ClearLastViewedAt() {
	m.last_viewed_at = nil
	m.clearedFields[place.FieldLastViewedAt] = struct{}{}
}

// LastViewedAtCleared returns if the "last_viewed_at" field was cleared in this mutation.
func (m *PlaceMutation) LastViewedAtCleared() bool {
	_, ok := m.clearedFields[place.FieldLastViewedAt]
	return ok
}

// ResetLastViewedAt resets all changes to the "last_viewed_at" field.
func (m *PlaceMutation) ResetLastViewedAt() {
	m.last_viewed_at = nil
	delete(m.clearedFields, place.FieldLastViewedAt)
}

// SetPopularityScore sets the "popularity_score" field.
func (m *PlaceMutation) SetPopularityScore(d decimal.Decimal) {
	m.popularity_score = &d
}

// PopularityScore returns the value of the "popularity_score" field in the mutation.
func (m *PlaceMutation) PopularityScore() (r decimal.Decimal, exists bool) {
	v := m.popularity_score
	if v == nil {
		return
	}
	return *v, true
}

// OldPopularityScore returns the old "popularity_score" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldPopularityScore(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopularityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopularityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopularityScore: %w", err)
	}
	return oldValue.PopularityScore, nil
}

// ResetPopularityScore resets all changes to the "popularity_score" field.
func (m *PlaceMutation) ResetPopularityScore() {
	m.popularity_score = nil
}

// AddImageIDs adds the "images" edge to the PlaceImage entity by ids.
func (m *PlaceMutation) AddImageIDs(ids ...string) {
	if m.images == nil {
		m.images = make(map[string]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the PlaceImage entity.
func (m *PlaceMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the PlaceImage entity was cleared.
func (m *PlaceMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the PlaceImage entity by IDs.
func (m *PlaceMutation) RemoveImageIDs(ids ...string) {
	if m.removedimages == nil {
		m.removedimages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the PlaceImage entity.
func (m *PlaceMutation) RemovedImagesIDs() (ids []string) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *PlaceMutation) ImagesIDs() (ids []string) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *PlaceMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// Where appends a list predicates to the PlaceMutation builder.
func (m *PlaceMutation) Where(ps ...predicate.Place) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Place, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Place).
func (m *PlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaceMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.status != nil {
		fields = append(fields, place.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, place.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, place.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, place.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, place.FieldUpdatedBy)
	}
	if m.metadata != nil {
		fields = append(fields, place.FieldMetadata)
	}
	if m.slug != nil {
		fields = append(fields, place.FieldSlug)
	}
	if m.title != nil {
		fields = append(fields, place.FieldTitle)
	}
	if m.subtitle != nil {
		fields = append(fields, place.FieldSubtitle)
	}
	if m.short_description != nil {
		fields = append(fields, place.FieldShortDescription)
	}
	if m.long_description != nil {
		fields = append(fields, place.FieldLongDescription)
	}
	if m.place_type != nil {
		fields = append(fields, place.FieldPlaceType)
	}
	if m.categories != nil {
		fields = append(fields, place.FieldCategories)
	}
	if m.address != nil {
		fields = append(fields, place.FieldAddress)
	}
	if m.latitude != nil {
		fields = append(fields, place.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, place.FieldLongitude)
	}
	if m.primary_image_url != nil {
		fields = append(fields, place.FieldPrimaryImageURL)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, place.FieldThumbnailURL)
	}
	if m.amenities != nil {
		fields = append(fields, place.FieldAmenities)
	}
	if m.view_count != nil {
		fields = append(fields, place.FieldViewCount)
	}
	if m.rating_avg != nil {
		fields = append(fields, place.FieldRatingAvg)
	}
	if m.rating_count != nil {
		fields = append(fields, place.FieldRatingCount)
	}
	if m.last_viewed_at != nil {
		fields = append(fields, place.FieldLastViewedAt)
	}
	if m.popularity_score != nil {
		fields = append(fields, place.FieldPopularityScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case place.FieldStatus:
		return m.Status()
	case place.FieldCreatedAt:
		return m.CreatedAt()
	case place.FieldUpdatedAt:
		return m.UpdatedAt()
	case place.FieldCreatedBy:
		return m.CreatedBy()
	case place.FieldUpdatedBy:
		return m.UpdatedBy()
	case place.FieldMetadata:
		return m.Metadata()
	case place.FieldSlug:
		return m.Slug()
	case place.FieldTitle:
		return m.Title()
	case place.FieldSubtitle:
		return m.Subtitle()
	case place.FieldShortDescription:
		return m.ShortDescription()
	case place.FieldLongDescription:
		return m.LongDescription()
	case place.FieldPlaceType:
		return m.PlaceType()
	case place.FieldCategories:
		return m.Categories()
	case place.FieldAddress:
		return m.Address()
	case place.FieldLatitude:
		return m.Latitude()
	case place.FieldLongitude:
		return m.Longitude()
	case place.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case place.FieldThumbnailURL:
		return m.ThumbnailURL()
	case place.FieldAmenities:
		return m.Amenities()
	case place.FieldViewCount:
		return m.ViewCount()
	case place.FieldRatingAvg:
		return m.RatingAvg()
	case place.FieldRatingCount:
		return m.RatingCount()
	case place.FieldLastViewedAt:
		return m.LastViewedAt()
	case place.FieldPopularityScore:
		return m.PopularityScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case place.FieldStatus:
		return m.OldStatus(ctx)
	case place.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case place.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case place.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case place.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case place.FieldMetadata:
		return m.OldMetadata(ctx)
	case place.FieldSlug:
		return m.OldSlug(ctx)
	case place.FieldTitle:
		return m.OldTitle(ctx)
	case place.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case place.FieldShortDescription:
		return m.OldShortDescription(ctx)
	case place.FieldLongDescription:
		return m.OldLongDescription(ctx)
	case place.FieldPlaceType:
		return m.OldPlaceType(ctx)
	case place.FieldCategories:
		return m.OldCategories(ctx)
	case place.FieldAddress:
		return m.OldAddress(ctx)
	case place.FieldLatitude:
		return m.OldLatitude(ctx)
	case place.FieldLongitude:
		return m.OldLongitude(ctx)
	case place.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case place.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case place.FieldAmenities:
		return m.OldAmenities(ctx)
	case place.FieldViewCount:
		return m.OldViewCount(ctx)
	case place.FieldRatingAvg:
		return m.OldRatingAvg(ctx)
	case place.FieldRatingCount:
		return m.OldRatingCount(ctx)
	case place.FieldLastViewedAt:
		return m.OldLastViewedAt(ctx)
	case place.FieldPopularityScore:
		return m.OldPopularityScore(ctx)
	}
	return nil, fmt.Errorf("unknown Place field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case place.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case place.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case place.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case place.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case place.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case place.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case place.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case place.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case place.FieldSubtitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case place.FieldShortDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortDescription(v)
		return nil
	case place.FieldLongDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongDescription(v)
		return nil
	case place.FieldPlaceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceType(v)
		return nil
	case place.FieldCategories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategories(v)
		return nil
	case place.FieldAddress:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case place.FieldLatitude:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case place.FieldLongitude:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case place.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case place.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case place.FieldAmenities:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmenities(v)
		return nil
	case place.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case place.FieldRatingAvg:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingAvg(v)
		return nil
	case place.FieldRatingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingCount(v)
		return nil
	case place.FieldLastViewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastViewedAt(v)
		return nil
	case place.FieldPopularityScore:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopularityScore(v)
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaceMutation) AddedFields() []string {
	var fields []string
	if m.addview_count != nil {
		fields = append(fields, place.FieldViewCount)
	}
	if m.addrating_count != nil {
		fields = append(fields, place.FieldRatingCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case place.FieldViewCount:
		return m.AddedViewCount()
	case place.FieldRatingCount:
		return m.AddedRatingCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case place.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case place.FieldRatingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatingCount(v)
		return nil
	}
	return fmt.Errorf("unknown Place numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(place.FieldCreatedBy) {
		fields = append(fields, place.FieldCreatedBy)
	}
	if m.FieldCleared(place.FieldUpdatedBy) {
		fields = append(fields, place.FieldUpdatedBy)
	}
	if m.FieldCleared(place.FieldMetadata) {
		fields = append(fields, place.FieldMetadata)
	}
	if m.FieldCleared(place.FieldSubtitle) {
		fields = append(fields, place.FieldSubtitle)
	}
	if m.FieldCleared(place.FieldShortDescription) {
		fields = append(fields, place.FieldShortDescription)
	}
	if m.FieldCleared(place.FieldLongDescription) {
		fields = append(fields, place.FieldLongDescription)
	}
	if m.FieldCleared(place.FieldCategories) {
		fields = append(fields, place.FieldCategories)
	}
	if m.FieldCleared(place.FieldAddress) {
		fields = append(fields, place.FieldAddress)
	}
	if m.FieldCleared(place.FieldPrimaryImageURL) {
		fields = append(fields, place.FieldPrimaryImageURL)
	}
	if m.FieldCleared(place.FieldThumbnailURL) {
		fields = append(fields, place.FieldThumbnailURL)
	}
	if m.FieldCleared(place.FieldAmenities) {
		fields = append(fields, place.FieldAmenities)
	}
	if m.FieldCleared(place.FieldLastViewedAt) {
		fields = append(fields, place.FieldLastViewedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceMutation) ClearField(name string) error {
	switch name {
	case place.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case place.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case place.FieldMetadata:
		m.ClearMetadata()
		return nil
	case place.FieldSubtitle:
		m.ClearSubtitle()
		return nil
	case place.FieldShortDescription:
		m.ClearShortDescription()
		return nil
	case place.FieldLongDescription:
		m.ClearLongDescription()
		return nil
	case place.FieldCategories:
		m.ClearCategories()
		return nil
	case place.FieldAddress:
		m.ClearAddress()
		return nil
	case place.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case place.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case place.FieldAmenities:
		m.ClearAmenities()
		return nil
	case place.FieldLastViewedAt:
		m.ClearLastViewedAt()
		return nil
	}
	return fmt.Errorf("unknown Place nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaceMutation) ResetField(name string) error {
	switch name {
	case place.FieldStatus:
		m.ResetStatus()
		return nil
	case place.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case place.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case place.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case place.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case place.FieldMetadata:
		m.ResetMetadata()
		return nil
	case place.FieldSlug:
		m.ResetSlug()
		return nil
	case place.FieldTitle:
		m.ResetTitle()
		return nil
	case place.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case place.FieldShortDescription:
		m.ResetShortDescription()
		return nil
	case place.FieldLongDescription:
		m.ResetLongDescription()
		return nil
	case place.FieldPlaceType:
		m.ResetPlaceType()
		return nil
	case place.FieldCategories:
		m.ResetCategories()
		return nil
	case place.FieldAddress:
		m.ResetAddress()
		return nil
	case place.FieldLatitude:
		m.ResetLatitude()
		return nil
	case place.FieldLongitude:
		m.ResetLongitude()
		return nil
	case place.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case place.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case place.FieldAmenities:
		m.ResetAmenities()
		return nil
	case place.FieldViewCount:
		m.ResetViewCount()
		return nil
	case place.FieldRatingAvg:
		m.ResetRatingAvg()
		return nil
	case place.FieldRatingCount:
		m.ResetRatingCount()
		return nil
	case place.FieldLastViewedAt:
		m.ResetLastViewedAt()
		return nil
	case place.FieldPopularityScore:
		m.ResetPopularityScore()
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.images != nil {
		edges = append(edges, place.EdgeImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case place.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedimages != nil {
		edges = append(edges, place.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case place.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedimages {
		edges = append(edges, place.EdgeImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case place.EdgeImages:
		return m.clearedimages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Place unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaceMutation) ResetEdge(name string) error {
	switch name {
	case place.EdgeImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown Place edge %s", name)
}

// PlaceImageMutation represents an operation that mutates the PlaceImage nodes in the graph.
type PlaceImageMutation struct {
	config
	op            Op
	typ           string
	id            *string
	status        *string
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	metadata      *map[string]string
	url           *string
	alt           *string
	pos           *int
	addpos        *int
	clearedFields map[string]struct{}
	place         *string
	clearedplace  bool
	done          bool
	oldValue      func(context.Context) (*PlaceImage, error)
	predicates    []predicate.PlaceImage
}

var _ ent.Mutation = (*PlaceImageMutation)(nil)

// placeimageOption allows management of the mutation configuration using functional options.
type placeimageOption func(*PlaceImageMutation)

// newPlaceImageMutation creates new mutation for the PlaceImage entity.
func newPlaceImageMutation(c config, op Op, opts ...placeimageOption) *PlaceImageMutation {
	m := &PlaceImageMutation{
		config:        c,
		op:            op,
		typ:           TypePlaceImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceImageID sets the ID field of the mutation.
func withPlaceImageID(id string) placeimageOption {
	return func(m *PlaceImageMutation) {
		var (
			err   error
			once  sync.Once
			value *PlaceImage
		)
		m.oldValue = func(ctx context.Context) (*PlaceImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlaceImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaceImage sets the old PlaceImage of the mutation.
func withPlaceImage(node *PlaceImage) placeimageOption {
	return func(m *PlaceImageMutation) {
		m.oldValue = func(context.Context) (*PlaceImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlaceImage entities.
func (m *PlaceImageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaceImageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaceImageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlaceImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *PlaceImageMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PlaceImageMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PlaceImage entity.
// If the PlaceImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceImageMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PlaceImageMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PlaceImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlaceImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlaceImage entity.
// If the PlaceImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlaceImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlaceImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlaceImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlaceImage entity.
// If the PlaceImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlaceImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PlaceImageMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PlaceImageMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PlaceImage entity.
// If the PlaceImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceImageMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PlaceImageMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[placeimage.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PlaceImageMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[placeimage.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PlaceImageMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, placeimage.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PlaceImageMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PlaceImageMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PlaceImage entity.
// If the PlaceImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceImageMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PlaceImageMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[placeimage.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PlaceImageMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[placeimage.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PlaceImageMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, placeimage.FieldUpdatedBy)
}

// SetMetadata sets the "metadata" field.
func (m *PlaceImageMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PlaceImageMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PlaceImage entity.
// If the PlaceImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceImageMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PlaceImageMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[placeimage.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PlaceImageMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[placeimage.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PlaceImageMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, placeimage.FieldMetadata)
}

// SetPlaceID sets the "place_id" field.
func (m *PlaceImageMutation) SetPlaceID(s string) {
	m.place = &s
}

// PlaceID returns the value of the "place_id" field in the mutation.
func (m *PlaceImageMutation) PlaceID() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceID returns the old "place_id" field's value of the PlaceImage entity.
// If the PlaceImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceImageMutation) OldPlaceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceID: %w", err)
	}
	return oldValue.PlaceID, nil
}

// ResetPlaceID resets all changes to the "place_id" field.
func (m *PlaceImageMutation) ResetPlaceID() {
	m.place = nil
}

// SetURL sets the "url" field.
func (m *PlaceImageMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *PlaceImageMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the PlaceImage entity.
// If the PlaceImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceImageMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *PlaceImageMutation) ResetURL() {
	m.url = nil
}

// SetAlt sets the "alt" field.
func (m *PlaceImageMutation) SetAlt(s string) {
	m.alt = &s
}

// Alt returns the value of the "alt" field in the mutation.
func (m *PlaceImageMutation) Alt() (r string, exists bool) {
	v := m.alt
	if v == nil {
		return
	}
	return *v, true
}

// OldAlt returns the old "alt" field's value of the PlaceImage entity.
// If the PlaceImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceImageMutation) OldAlt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlt: %w", err)
	}
	return oldValue.Alt, nil
}

// ClearAlt clears the value of the "alt" field.
func (m *PlaceImageMutation) ClearAlt() {
	m.alt = nil
	m.clearedFields[placeimage.FieldAlt] = struct{}{}
}

// AltCleared returns if the "alt" field was cleared in this mutation.
func (m *PlaceImageMutation) AltCleared() bool {
	_, ok := m.clearedFields[placeimage.FieldAlt]
	return ok
}

// ResetAlt resets all changes to the "alt" field.
func (m *PlaceImageMutation) ResetAlt() {
	m.alt = nil
	delete(m.clearedFields, placeimage.FieldAlt)
}

// SetPos sets the "pos" field.
func (m *PlaceImageMutation) SetPos(i int) {
	m.pos = &i
	m.addpos = nil
}

// Pos returns the value of the "pos" field in the mutation.
func (m *PlaceImageMutation) Pos() (r int, exists bool) {
	v := m.pos
	if v == nil {
		return
	}
	return *v, true
}

// OldPos returns the old "pos" field's value of the PlaceImage entity.
// If the PlaceImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceImageMutation) OldPos(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPos: %w", err)
	}
	return oldValue.Pos, nil
}

// AddPos adds i to the "pos" field.
func (m *PlaceImageMutation) AddPos(i int) {
	if m.addpos != nil {
		*m.addpos += i
	} else {
		m.addpos = &i
	}
}

// AddedPos returns the value that was added to the "pos" field in this mutation.
func (m *PlaceImageMutation) AddedPos() (r int, exists bool) {
	v := m.addpos
	if v == nil {
		return
	}
	return *v, true
}

// ResetPos resets all changes to the "pos" field.
func (m *PlaceImageMutation) ResetPos() {
	m.pos = nil
	m.addpos = nil
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *PlaceImageMutation) ClearPlace() {
	m.clearedplace = true
	m.clearedFields[placeimage.FieldPlaceID] = struct{}{}
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *PlaceImageMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *PlaceImageMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *PlaceImageMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// Where appends a list predicates to the PlaceImageMutation builder.
func (m *PlaceImageMutation) Where(ps ...predicate.PlaceImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaceImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaceImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlaceImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaceImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaceImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlaceImage).
func (m *PlaceImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaceImageMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.status != nil {
		fields = append(fields, placeimage.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, placeimage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, placeimage.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, placeimage.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, placeimage.FieldUpdatedBy)
	}
	if m.metadata != nil {
		fields = append(fields, placeimage.FieldMetadata)
	}
	if m.place != nil {
		fields = append(fields, placeimage.FieldPlaceID)
	}
	if m.url != nil {
		fields = append(fields, placeimage.FieldURL)
	}
	if m.alt != nil {
		fields = append(fields, placeimage.FieldAlt)
	}
	if m.pos != nil {
		fields = append(fields, placeimage.FieldPos)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaceImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case placeimage.FieldStatus:
		return m.Status()
	case placeimage.FieldCreatedAt:
		return m.CreatedAt()
	case placeimage.FieldUpdatedAt:
		return m.UpdatedAt()
	case placeimage.FieldCreatedBy:
		return m.CreatedBy()
	case placeimage.FieldUpdatedBy:
		return m.UpdatedBy()
	case placeimage.FieldMetadata:
		return m.Metadata()
	case placeimage.FieldPlaceID:
		return m.PlaceID()
	case placeimage.FieldURL:
		return m.URL()
	case placeimage.FieldAlt:
		return m.Alt()
	case placeimage.FieldPos:
		return m.Pos()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaceImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case placeimage.FieldStatus:
		return m.OldStatus(ctx)
	case placeimage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case placeimage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case placeimage.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case placeimage.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case placeimage.FieldMetadata:
		return m.OldMetadata(ctx)
	case placeimage.FieldPlaceID:
		return m.OldPlaceID(ctx)
	case placeimage.FieldURL:
		return m.OldURL(ctx)
	case placeimage.FieldAlt:
		return m.OldAlt(ctx)
	case placeimage.FieldPos:
		return m.OldPos(ctx)
	}
	return nil, fmt.Errorf("unknown PlaceImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case placeimage.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case placeimage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case placeimage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case placeimage.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case placeimage.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case placeimage.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case placeimage.FieldPlaceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceID(v)
		return nil
	case placeimage.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case placeimage.FieldAlt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlt(v)
		return nil
	case placeimage.FieldPos:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPos(v)
		return nil
	}
	return fmt.Errorf("unknown PlaceImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaceImageMutation) AddedFields() []string {
	var fields []string
	if m.addpos != nil {
		fields = append(fields, placeimage.FieldPos)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaceImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case placeimage.FieldPos:
		return m.AddedPos()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case placeimage.FieldPos:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPos(v)
		return nil
	}
	return fmt.Errorf("unknown PlaceImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaceImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(placeimage.FieldCreatedBy) {
		fields = append(fields, placeimage.FieldCreatedBy)
	}
	if m.FieldCleared(placeimage.FieldUpdatedBy) {
		fields = append(fields, placeimage.FieldUpdatedBy)
	}
	if m.FieldCleared(placeimage.FieldMetadata) {
		fields = append(fields, placeimage.FieldMetadata)
	}
	if m.FieldCleared(placeimage.FieldAlt) {
		fields = append(fields, placeimage.FieldAlt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaceImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceImageMutation) ClearField(name string) error {
	switch name {
	case placeimage.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case placeimage.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case placeimage.FieldMetadata:
		m.ClearMetadata()
		return nil
	case placeimage.FieldAlt:
		m.ClearAlt()
		return nil
	}
	return fmt.Errorf("unknown PlaceImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaceImageMutation) ResetField(name string) error {
	switch name {
	case placeimage.FieldStatus:
		m.ResetStatus()
		return nil
	case placeimage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case placeimage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case placeimage.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case placeimage.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case placeimage.FieldMetadata:
		m.ResetMetadata()
		return nil
	case placeimage.FieldPlaceID:
		m.ResetPlaceID()
		return nil
	case placeimage.FieldURL:
		m.ResetURL()
		return nil
	case placeimage.FieldAlt:
		m.ResetAlt()
		return nil
	case placeimage.FieldPos:
		m.ResetPos()
		return nil
	}
	return fmt.Errorf("unknown PlaceImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaceImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.place != nil {
		edges = append(edges, placeimage.EdgePlace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaceImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case placeimage.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaceImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaceImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaceImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplace {
		edges = append(edges, placeimage.EdgePlace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaceImageMutation) EdgeCleared(name string) bool {
	switch name {
	case placeimage.EdgePlace:
		return m.clearedplace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaceImageMutation) ClearEdge(name string) error {
	switch name {
	case placeimage.EdgePlace:
		m.ClearPlace()
		return nil
	}
	return fmt.Errorf("unknown PlaceImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaceImageMutation) ResetEdge(name string) error {
	switch name {
	case placeimage.EdgePlace:
		m.ResetPlace()
		return nil
	}
	return fmt.Errorf("unknown PlaceImage edge %s", name)
}

// ReviewMutation represents an operation that mutates the Review nodes in the graph.
type ReviewMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	status               *string
	created_at           *time.Time
	updated_at           *time.Time
	created_by           *string
	updated_by           *string
	metadata             *map[string]string
	entity_type          *string
	entity_id            *string
	user_id              *string
	rating               *decimal.Decimal
	title                *string
	content              *string
	tags                 *[]string
	appendtags           []string
	images               *[]string
	appendimages         []string
	helpful_count        *int
	addhelpful_count     *int
	not_helpful_count    *int
	addnot_helpful_count *int
	is_verified          *bool
	is_featured          *bool
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Review, error)
	predicates           []predicate.Review
}

var _ ent.Mutation = (*ReviewMutation)(nil)

// reviewOption allows management of the mutation configuration using functional options.
type reviewOption func(*ReviewMutation)

// newReviewMutation creates new mutation for the Review entity.
func newReviewMutation(c config, op Op, opts ...reviewOption) *ReviewMutation {
	m := &ReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewID sets the ID field of the mutation.
func withReviewID(id string) reviewOption {
	return func(m *ReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Review
		)
		m.oldValue = func(ctx context.Context) (*Review, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Review.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReview sets the old Review of the mutation.
func withReview(node *Review) reviewOption {
	return func(m *ReviewMutation) {
		m.oldValue = func(context.Context) (*Review, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Review entities.
func (m *ReviewMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Review.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *ReviewMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ReviewMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReviewMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ReviewMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ReviewMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ReviewMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[review.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ReviewMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[review.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ReviewMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, review.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ReviewMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ReviewMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ReviewMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[review.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ReviewMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[review.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ReviewMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, review.FieldUpdatedBy)
}

// SetMetadata sets the "metadata" field.
func (m *ReviewMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ReviewMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ReviewMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[review.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ReviewMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[review.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ReviewMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, review.FieldMetadata)
}

// SetEntityType sets the "entity_type" field.
func (m *ReviewMutation) SetEntityType(s string) {
	m.entity_type = &s
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *ReviewMutation) EntityType() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldEntityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *ReviewMutation) ResetEntityType() {
	m.entity_type = nil
}

// SetEntityID sets the "entity_id" field.
func (m *ReviewMutation) SetEntityID(s string) {
	m.entity_id = &s
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *ReviewMutation) EntityID() (r string, exists bool) {
	v := m.entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldEntityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *ReviewMutation) ResetEntityID() {
	m.entity_id = nil
}

// SetUserID sets the "user_id" field.
func (m *ReviewMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ReviewMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ReviewMutation) ResetUserID() {
	m.user_id = nil
}

// SetRating sets the "rating" field.
func (m *ReviewMutation) SetRating(d decimal.Decimal) {
	m.rating = &d
}

// Rating returns the value of the "rating" field in the mutation.
func (m *ReviewMutation) Rating() (r decimal.Decimal, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldRating(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// ResetRating resets all changes to the "rating" field.
func (m *ReviewMutation) ResetRating() {
	m.rating = nil
}

// SetTitle sets the "title" field.
func (m *ReviewMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ReviewMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ReviewMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[review.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ReviewMutation) TitleCleared() bool {
	_, ok := m.clearedFields[review.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ReviewMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, review.FieldTitle)
}

// SetContent sets the "content" field.
func (m *ReviewMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ReviewMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *ReviewMutation) ClearContent() {
	m.content = nil
	m.clearedFields[review.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *ReviewMutation) ContentCleared() bool {
	_, ok := m.clearedFields[review.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *ReviewMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, review.FieldContent)
}

// SetTags sets the "tags" field.
func (m *ReviewMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ReviewMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ReviewMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ReviewMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ReviewMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[review.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ReviewMutation) TagsCleared() bool {
	_, ok := m.clearedFields[review.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ReviewMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, review.FieldTags)
}

// SetImages sets the "images" field.
func (m *ReviewMutation) SetImages(s []string) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *ReviewMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *ReviewMutation) AppendImages(s []string) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *ReviewMutation) AppendedImages() ([]string, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *ReviewMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[review.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *ReviewMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[review.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *ReviewMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, review.FieldImages)
}

// SetHelpfulCount sets the "helpful_count" field.
func (m *ReviewMutation) SetHelpfulCount(i int) {
	m.helpful_count = &i
	m.addhelpful_count = nil
}

// HelpfulCount returns the value of the "helpful_count" field in the mutation.
func (m *ReviewMutation) HelpfulCount() (r int, exists bool) {
	v := m.helpful_count
	if v == nil {
		return
	}
	return *v, true
}

// OldHelpfulCount returns the old "helpful_count" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldHelpfulCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHelpfulCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHelpfulCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHelpfulCount: %w", err)
	}
	return oldValue.HelpfulCount, nil
}

// AddHelpfulCount adds i to the "helpful_count" field.
func (m *ReviewMutation) AddHelpfulCount(i int) {
	if m.addhelpful_count != nil {
		*m.addhelpful_count += i
	} else {
		m.addhelpful_count = &i
	}
}

// AddedHelpfulCount returns the value that was added to the "helpful_count" field in this mutation.
func (m *ReviewMutation) AddedHelpfulCount() (r int, exists bool) {
	v := m.addhelpful_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetHelpfulCount resets all changes to the "helpful_count" field.
func (m *ReviewMutation) ResetHelpfulCount() {
	m.helpful_count = nil
	m.addhelpful_count = nil
}

// SetNotHelpfulCount sets the "not_helpful_count" field.
func (m *ReviewMutation) SetNotHelpfulCount(i int) {
	m.not_helpful_count = &i
	m.addnot_helpful_count = nil
}

// NotHelpfulCount returns the value of the "not_helpful_count" field in the mutation.
func (m *ReviewMutation) NotHelpfulCount() (r int, exists bool) {
	v := m.not_helpful_count
	if v == nil {
		return
	}
	return *v, true
}

// OldNotHelpfulCount returns the old "not_helpful_count" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldNotHelpfulCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotHelpfulCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotHelpfulCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotHelpfulCount: %w", err)
	}
	return oldValue.NotHelpfulCount, nil
}

// AddNotHelpfulCount adds i to the "not_helpful_count" field.
func (m *ReviewMutation) AddNotHelpfulCount(i int) {
	if m.addnot_helpful_count != nil {
		*m.addnot_helpful_count += i
	} else {
		m.addnot_helpful_count = &i
	}
}

// AddedNotHelpfulCount returns the value that was added to the "not_helpful_count" field in this mutation.
func (m *ReviewMutation) AddedNotHelpfulCount() (r int, exists bool) {
	v := m.addnot_helpful_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetNotHelpfulCount resets all changes to the "not_helpful_count" field.
func (m *ReviewMutation) ResetNotHelpfulCount() {
	m.not_helpful_count = nil
	m.addnot_helpful_count = nil
}

// SetIsVerified sets the "is_verified" field.
func (m *ReviewMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *ReviewMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *ReviewMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetIsFeatured sets the "is_featured" field.
func (m *ReviewMutation) SetIsFeatured(b bool) {
	m.is_featured = &b
}

// IsFeatured returns the value of the "is_featured" field in the mutation.
func (m *ReviewMutation) IsFeatured() (r bool, exists bool) {
	v := m.is_featured
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFeatured returns the old "is_featured" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldIsFeatured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFeatured: %w", err)
	}
	return oldValue.IsFeatured, nil
}

// ResetIsFeatured resets all changes to the "is_featured" field.
func (m *ReviewMutation) ResetIsFeatured() {
	m.is_featured = nil
}

// Where appends a list predicates to the ReviewMutation builder.
func (m *ReviewMutation) Where(ps ...predicate.Review) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Review, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Review).
func (m *ReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.status != nil {
		fields = append(fields, review.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, review.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, review.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, review.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, review.FieldUpdatedBy)
	}
	if m.metadata != nil {
		fields = append(fields, review.FieldMetadata)
	}
	if m.entity_type != nil {
		fields = append(fields, review.FieldEntityType)
	}
	if m.entity_id != nil {
		fields = append(fields, review.FieldEntityID)
	}
	if m.user_id != nil {
		fields = append(fields, review.FieldUserID)
	}
	if m.rating != nil {
		fields = append(fields, review.FieldRating)
	}
	if m.title != nil {
		fields = append(fields, review.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, review.FieldContent)
	}
	if m.tags != nil {
		fields = append(fields, review.FieldTags)
	}
	if m.images != nil {
		fields = append(fields, review.FieldImages)
	}
	if m.helpful_count != nil {
		fields = append(fields, review.FieldHelpfulCount)
	}
	if m.not_helpful_count != nil {
		fields = append(fields, review.FieldNotHelpfulCount)
	}
	if m.is_verified != nil {
		fields = append(fields, review.FieldIsVerified)
	}
	if m.is_featured != nil {
		fields = append(fields, review.FieldIsFeatured)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case review.FieldStatus:
		return m.Status()
	case review.FieldCreatedAt:
		return m.CreatedAt()
	case review.FieldUpdatedAt:
		return m.UpdatedAt()
	case review.FieldCreatedBy:
		return m.CreatedBy()
	case review.FieldUpdatedBy:
		return m.UpdatedBy()
	case review.FieldMetadata:
		return m.Metadata()
	case review.FieldEntityType:
		return m.EntityType()
	case review.FieldEntityID:
		return m.EntityID()
	case review.FieldUserID:
		return m.UserID()
	case review.FieldRating:
		return m.Rating()
	case review.FieldTitle:
		return m.Title()
	case review.FieldContent:
		return m.Content()
	case review.FieldTags:
		return m.Tags()
	case review.FieldImages:
		return m.Images()
	case review.FieldHelpfulCount:
		return m.HelpfulCount()
	case review.FieldNotHelpfulCount:
		return m.NotHelpfulCount()
	case review.FieldIsVerified:
		return m.IsVerified()
	case review.FieldIsFeatured:
		return m.IsFeatured()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case review.FieldStatus:
		return m.OldStatus(ctx)
	case review.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case review.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case review.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case review.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case review.FieldMetadata:
		return m.OldMetadata(ctx)
	case review.FieldEntityType:
		return m.OldEntityType(ctx)
	case review.FieldEntityID:
		return m.OldEntityID(ctx)
	case review.FieldUserID:
		return m.OldUserID(ctx)
	case review.FieldRating:
		return m.OldRating(ctx)
	case review.FieldTitle:
		return m.OldTitle(ctx)
	case review.FieldContent:
		return m.OldContent(ctx)
	case review.FieldTags:
		return m.OldTags(ctx)
	case review.FieldImages:
		return m.OldImages(ctx)
	case review.FieldHelpfulCount:
		return m.OldHelpfulCount(ctx)
	case review.FieldNotHelpfulCount:
		return m.OldNotHelpfulCount(ctx)
	case review.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case review.FieldIsFeatured:
		return m.OldIsFeatured(ctx)
	}
	return nil, fmt.Errorf("unknown Review field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case review.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case review.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case review.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case review.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case review.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case review.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case review.FieldEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case review.FieldEntityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case review.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case review.FieldRating:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case review.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case review.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case review.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case review.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case review.FieldHelpfulCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHelpfulCount(v)
		return nil
	case review.FieldNotHelpfulCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotHelpfulCount(v)
		return nil
	case review.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case review.FieldIsFeatured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFeatured(v)
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewMutation) AddedFields() []string {
	var fields []string
	if m.addhelpful_count != nil {
		fields = append(fields, review.FieldHelpfulCount)
	}
	if m.addnot_helpful_count != nil {
		fields = append(fields, review.FieldNotHelpfulCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case review.FieldHelpfulCount:
		return m.AddedHelpfulCount()
	case review.FieldNotHelpfulCount:
		return m.AddedNotHelpfulCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case review.FieldHelpfulCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHelpfulCount(v)
		return nil
	case review.FieldNotHelpfulCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotHelpfulCount(v)
		return nil
	}
	return fmt.Errorf("unknown Review numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(review.FieldCreatedBy) {
		fields = append(fields, review.FieldCreatedBy)
	}
	if m.FieldCleared(review.FieldUpdatedBy) {
		fields = append(fields, review.FieldUpdatedBy)
	}
	if m.FieldCleared(review.FieldMetadata) {
		fields = append(fields, review.FieldMetadata)
	}
	if m.FieldCleared(review.FieldTitle) {
		fields = append(fields, review.FieldTitle)
	}
	if m.FieldCleared(review.FieldContent) {
		fields = append(fields, review.FieldContent)
	}
	if m.FieldCleared(review.FieldTags) {
		fields = append(fields, review.FieldTags)
	}
	if m.FieldCleared(review.FieldImages) {
		fields = append(fields, review.FieldImages)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewMutation) ClearField(name string) error {
	switch name {
	case review.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case review.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case review.FieldMetadata:
		m.ClearMetadata()
		return nil
	case review.FieldTitle:
		m.ClearTitle()
		return nil
	case review.FieldContent:
		m.ClearContent()
		return nil
	case review.FieldTags:
		m.ClearTags()
		return nil
	case review.FieldImages:
		m.ClearImages()
		return nil
	}
	return fmt.Errorf("unknown Review nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewMutation) ResetField(name string) error {
	switch name {
	case review.FieldStatus:
		m.ResetStatus()
		return nil
	case review.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case review.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case review.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case review.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case review.FieldMetadata:
		m.ResetMetadata()
		return nil
	case review.FieldEntityType:
		m.ResetEntityType()
		return nil
	case review.FieldEntityID:
		m.ResetEntityID()
		return nil
	case review.FieldUserID:
		m.ResetUserID()
		return nil
	case review.FieldRating:
		m.ResetRating()
		return nil
	case review.FieldTitle:
		m.ResetTitle()
		return nil
	case review.FieldContent:
		m.ResetContent()
		return nil
	case review.FieldTags:
		m.ResetTags()
		return nil
	case review.FieldImages:
		m.ResetImages()
		return nil
	case review.FieldHelpfulCount:
		m.ResetHelpfulCount()
		return nil
	case review.FieldNotHelpfulCount:
		m.ResetNotHelpfulCount()
		return nil
	case review.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case review.FieldIsFeatured:
		m.ResetIsFeatured()
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Review unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Review edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *string
	status        *string
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	metadata      *map[string]string
	name          *string
	email         *string
	phone         *string
	role          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[user.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, user.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[user.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, user.FieldUpdatedBy)
}

// SetMetadata sets the "metadata" field.
func (m *UserMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *UserMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *UserMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[user.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *UserMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[user.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *UserMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, user.FieldMetadata)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.metadata != nil {
		fields = append(fields, user.FieldMetadata)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.Status()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldMetadata:
		return m.Metadata()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldMetadata:
		return m.OldMetadata(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedBy) {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.FieldCleared(user.FieldUpdatedBy) {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.FieldCleared(user.FieldMetadata) {
		fields = append(fields, user.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case user.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldMetadata:
		m.ResetMetadata()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

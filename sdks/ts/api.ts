/* tslint:disable */
/* eslint-disable */
/**
 * Nashik Darshan API
 * API for Nashik Darshan
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@nashikdarshan.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface DtoCategoryResponse
 */
export interface DtoCategoryResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoCategoryResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'slug'?: string;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoCategoryResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'updated_by'?: string;
}


/**
 * 
 * @export
 * @interface DtoCreateCategoryRequest
 */
export interface DtoCreateCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoCreateCategoryRequest
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoCreateCategoryRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoCreateCategoryRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateCategoryRequest
     */
    'slug': string;
}
/**
 * 
 * @export
 * @interface DtoCreatePlaceImageRequest
 */
export interface DtoCreatePlaceImageRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceImageRequest
     */
    'alt'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoCreatePlaceImageRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof DtoCreatePlaceImageRequest
     */
    'pos'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceImageRequest
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface DtoCreatePlaceRequest
 */
export interface DtoCreatePlaceRequest {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoCreatePlaceRequest
     */
    'address'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoCreatePlaceRequest
     */
    'amenities'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoCreatePlaceRequest
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {TypesLocation}
     * @memberof DtoCreatePlaceRequest
     */
    'location': TypesLocation;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'long_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'place_type': string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'primary_image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'short_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'subtitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'thumbnail_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface DtoCreateReviewRequest
 */
export interface DtoCreateReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoCreateReviewRequest
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateReviewRequest
     */
    'entity_id': string;
    /**
     * 
     * @type {TypesReviewEntityType}
     * @memberof DtoCreateReviewRequest
     */
    'entity_type': TypesReviewEntityType;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoCreateReviewRequest
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoCreateReviewRequest
     */
    'rating': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoCreateReviewRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateReviewRequest
     */
    'title'?: string;
}


/**
 * 
 * @export
 * @interface DtoFeedRequest
 */
export interface DtoFeedRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoFeedRequest
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedRequest
     */
    'expand'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedRequest
     */
    'offset'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedRequest
     */
    'order'?: DtoFeedRequestOrderEnum;
    /**
     * 
     * @type {Array<DtoFeedSectionRequest>}
     * @memberof DtoFeedRequest
     */
    'sections': Array<DtoFeedSectionRequest>;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedRequest
     */
    'sort'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedRequest
     */
    'start_time'?: string;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoFeedRequest
     */
    'status'?: TypesStatus;
}

export const DtoFeedRequestOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type DtoFeedRequestOrderEnum = typeof DtoFeedRequestOrderEnum[keyof typeof DtoFeedRequestOrderEnum];

/**
 * 
 * @export
 * @interface DtoFeedResponse
 */
export interface DtoFeedResponse {
    /**
     * 
     * @type {Array<DtoFeedSectionResponse>}
     * @memberof DtoFeedResponse
     */
    'sections'?: Array<DtoFeedSectionResponse>;
}
/**
 * 
 * @export
 * @interface DtoFeedSectionRequest
 */
export interface DtoFeedSectionRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoFeedSectionRequest
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedSectionRequest
     */
    'expand'?: string;
    /**
     * Geospatial fields (for nearby section)
     * @type {number}
     * @memberof DtoFeedSectionRequest
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedSectionRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedSectionRequest
     */
    'longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedSectionRequest
     */
    'offset'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedSectionRequest
     */
    'order'?: DtoFeedSectionRequestOrderEnum;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedSectionRequest
     */
    'radius_km'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedSectionRequest
     */
    'sort'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedSectionRequest
     */
    'start_time'?: string;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoFeedSectionRequest
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {TypesFeedSectionType}
     * @memberof DtoFeedSectionRequest
     */
    'type': TypesFeedSectionType;
}

export const DtoFeedSectionRequestOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type DtoFeedSectionRequestOrderEnum = typeof DtoFeedSectionRequestOrderEnum[keyof typeof DtoFeedSectionRequestOrderEnum];

/**
 * 
 * @export
 * @interface DtoFeedSectionResponse
 */
export interface DtoFeedSectionResponse {
    /**
     * 
     * @type {Array<DtoPlaceResponse>}
     * @memberof DtoFeedSectionResponse
     */
    'items'?: Array<DtoPlaceResponse>;
    /**
     * 
     * @type {TypesPaginationResponse}
     * @memberof DtoFeedSectionResponse
     */
    'pagination'?: TypesPaginationResponse;
    /**
     * 
     * @type {TypesFeedSectionType}
     * @memberof DtoFeedSectionResponse
     */
    'type'?: TypesFeedSectionType;
}


/**
 * 
 * @export
 * @interface DtoListCategoriesResponse
 */
export interface DtoListCategoriesResponse {
    /**
     * 
     * @type {Array<DtoCategoryResponse>}
     * @memberof DtoListCategoriesResponse
     */
    'items'?: Array<DtoCategoryResponse>;
    /**
     * 
     * @type {TypesPaginationResponse}
     * @memberof DtoListCategoriesResponse
     */
    'pagination'?: TypesPaginationResponse;
}
/**
 * 
 * @export
 * @interface DtoListPlacesResponse
 */
export interface DtoListPlacesResponse {
    /**
     * 
     * @type {Array<DtoPlaceResponse>}
     * @memberof DtoListPlacesResponse
     */
    'items'?: Array<DtoPlaceResponse>;
    /**
     * 
     * @type {TypesPaginationResponse}
     * @memberof DtoListPlacesResponse
     */
    'pagination'?: TypesPaginationResponse;
}
/**
 * 
 * @export
 * @interface DtoMeResponse
 */
export interface DtoMeResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoMeResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'phone'?: string;
    /**
     * 
     * @type {TypesUserRole}
     * @memberof DtoMeResponse
     */
    'role'?: TypesUserRole;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoMeResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'updated_by'?: string;
}


/**
 * 
 * @export
 * @interface DtoPlaceImageResponse
 */
export interface DtoPlaceImageResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'alt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoPlaceImageResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'place_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoPlaceImageResponse
     */
    'pos'?: number;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoPlaceImageResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'url'?: string;
}


/**
 * 
 * @export
 * @interface DtoPlaceResponse
 */
export interface DtoPlaceResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoPlaceResponse
     */
    'address'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoPlaceResponse
     */
    'amenities'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoPlaceResponse
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'id'?: string;
    /**
     * 
     * @type {Array<DtoPlaceImageResponse>}
     * @memberof DtoPlaceResponse
     */
    'images'?: Array<DtoPlaceImageResponse>;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'last_viewed_at'?: string;
    /**
     * 
     * @type {TypesLocation}
     * @memberof DtoPlaceResponse
     */
    'location'?: TypesLocation;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'long_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'place_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoPlaceResponse
     */
    'popularity_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'primary_image_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoPlaceResponse
     */
    'rating_avg'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoPlaceResponse
     */
    'rating_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'short_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'slug'?: string;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoPlaceResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'subtitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'thumbnail_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'updated_by'?: string;
    /**
     * Engagement fields for feed functionality
     * @type {number}
     * @memberof DtoPlaceResponse
     */
    'view_count'?: number;
}


/**
 * 
 * @export
 * @interface DtoRatingStatsResponse
 */
export interface DtoRatingStatsResponse {
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'average_rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoRatingStatsResponse
     */
    'entity_id'?: string;
    /**
     * 
     * @type {TypesReviewEntityType}
     * @memberof DtoRatingStatsResponse
     */
    'entity_type'?: TypesReviewEntityType;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'five_star_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'four_star_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'one_star_count'?: number;
    /**
     * rating -> count
     * @type {{ [key: string]: number; }}
     * @memberof DtoRatingStatsResponse
     */
    'rating_distribution'?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'reviews_with_content'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'reviews_with_images'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'three_star_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'total_reviews'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'two_star_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'verified_reviews'?: number;
}


/**
 * 
 * @export
 * @interface DtoReviewResponse
 */
export interface DtoReviewResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'entity_id'?: string;
    /**
     * 
     * @type {TypesReviewEntityType}
     * @memberof DtoReviewResponse
     */
    'entity_type'?: TypesReviewEntityType;
    /**
     * 
     * @type {number}
     * @memberof DtoReviewResponse
     */
    'helpful_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoReviewResponse
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof DtoReviewResponse
     */
    'is_featured'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DtoReviewResponse
     */
    'is_verified'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DtoReviewResponse
     */
    'not_helpful_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoReviewResponse
     */
    'rating'?: number;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoReviewResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoReviewResponse
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'user_id'?: string;
}


/**
 * 
 * @export
 * @interface DtoSignupRequest
 */
export interface DtoSignupRequest {
    /**
     * access token
     * @type {string}
     * @memberof DtoSignupRequest
     */
    'access_token': string;
    /**
     * basic info
     * @type {string}
     * @memberof DtoSignupRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof DtoSignupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DtoSignupRequest
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface DtoSignupResponse
 */
export interface DtoSignupResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoSignupResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoSignupResponse
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface DtoUpdateCategoryRequest
 */
export interface DtoUpdateCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateCategoryRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateCategoryRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateCategoryRequest
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface DtoUpdatePlaceImageRequest
 */
export interface DtoUpdatePlaceImageRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceImageRequest
     */
    'alt'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoUpdatePlaceImageRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof DtoUpdatePlaceImageRequest
     */
    'pos'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceImageRequest
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface DtoUpdatePlaceRequest
 */
export interface DtoUpdatePlaceRequest {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoUpdatePlaceRequest
     */
    'address'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoUpdatePlaceRequest
     */
    'amenities'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoUpdatePlaceRequest
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {TypesLocation}
     * @memberof DtoUpdatePlaceRequest
     */
    'location'?: TypesLocation;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'long_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'place_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'primary_image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'short_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'subtitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'thumbnail_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface DtoUpdateReviewRequest
 */
export interface DtoUpdateReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateReviewRequest
     */
    'content'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoUpdateReviewRequest
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoUpdateReviewRequest
     */
    'rating'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoUpdateReviewRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateReviewRequest
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface DtoUpdateUserRequest
 */
export interface DtoUpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateUserRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateUserRequest
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface IerrErrorDetail
 */
export interface IerrErrorDetail {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof IerrErrorDetail
     */
    'details'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof IerrErrorDetail
     */
    'internal_error'?: string;
    /**
     * 
     * @type {string}
     * @memberof IerrErrorDetail
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface IerrErrorResponse
 */
export interface IerrErrorResponse {
    /**
     * 
     * @type {IerrErrorDetail}
     * @memberof IerrErrorResponse
     */
    'error'?: IerrErrorDetail;
    /**
     * 
     * @type {boolean}
     * @memberof IerrErrorResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface PlacePlaceImage
 */
export interface PlacePlaceImage {
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'alt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PlacePlaceImage
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'place_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlacePlaceImage
     */
    'pos'?: number;
    /**
     * 
     * @type {TypesStatus}
     * @memberof PlacePlaceImage
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'url'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TypesFeedSectionType = {
    SectionTypeLatest: 'latest',
    SectionTypeTrending: 'trending',
    SectionTypePopular: 'popular',
    SectionTypeNearby: 'nearby'
} as const;

export type TypesFeedSectionType = typeof TypesFeedSectionType[keyof typeof TypesFeedSectionType];


/**
 * 
 * @export
 * @interface TypesListResponseDtoReviewResponse
 */
export interface TypesListResponseDtoReviewResponse {
    /**
     * 
     * @type {Array<DtoReviewResponse>}
     * @memberof TypesListResponseDtoReviewResponse
     */
    'items'?: Array<DtoReviewResponse>;
    /**
     * 
     * @type {TypesPaginationResponse}
     * @memberof TypesListResponseDtoReviewResponse
     */
    'pagination'?: TypesPaginationResponse;
}
/**
 * 
 * @export
 * @interface TypesLocation
 */
export interface TypesLocation {
    /**
     * 
     * @type {number}
     * @memberof TypesLocation
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof TypesLocation
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface TypesPaginationResponse
 */
export interface TypesPaginationResponse {
    /**
     * 
     * @type {number}
     * @memberof TypesPaginationResponse
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof TypesPaginationResponse
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof TypesPaginationResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TypesReviewEntityType = {
    EntityTypePlace: 'place',
    EntityTypeHotel: 'hotel',
    EntityTypeRestaurant: 'restaurant',
    EntityTypeEvent: 'event',
    EntityTypeExperience: 'experience',
    EntityTypeAttraction: 'attraction'
} as const;

export type TypesReviewEntityType = typeof TypesReviewEntityType[keyof typeof TypesReviewEntityType];


/**
 * 
 * @export
 * @enum {string}
 */

export const TypesStatus = {
    StatusPublished: 'published',
    StatusDeleted: 'deleted',
    StatusArchived: 'archived',
    StatusInactive: 'inactive',
    StatusPending: 'pending'
} as const;

export type TypesStatus = typeof TypesStatus[keyof typeof TypesStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const TypesUserRole = {
    UserRoleUser: 'USER',
    UserRoleAdmin: 'ADMIN'
} as const;

export type TypesUserRole = typeof TypesUserRole[keyof typeof TypesUserRole];



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Signup
         * @summary Signup
         * @param {DtoSignupRequest} signupRequest Signup request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignupPost: async (signupRequest: DtoSignupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequest' is not null or undefined
            assertParamExists('authSignupPost', 'signupRequest', signupRequest)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Signup
         * @summary Signup
         * @param {DtoSignupRequest} signupRequest Signup request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSignupPost(signupRequest: DtoSignupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoSignupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSignupPost(signupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authSignupPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Signup
         * @summary Signup
         * @param {DtoSignupRequest} signupRequest Signup request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignupPost(signupRequest: DtoSignupRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoSignupResponse> {
            return localVarFp.authSignupPost(signupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Signup
     * @summary Signup
     * @param {DtoSignupRequest} signupRequest Signup request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSignupPost(signupRequest: DtoSignupRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSignupPost(signupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a paginated list of categories with filtering and pagination
         * @summary List categories
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [name] Filter by names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesGet: async (limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, name?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (slug) {
                localVarQueryParameter['slug'] = slug.join(COLLECTION_FORMATS.csv);
            }

            if (name) {
                localVarQueryParameter['name'] = name.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft delete a category
         * @summary Delete a category
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesIdDelete', 'id', id)
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a category by its ID
         * @summary Get category by ID
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesIdGet', 'id', id)
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing category
         * @summary Update a category
         * @param {string} id Category ID
         * @param {DtoUpdateCategoryRequest} request Update category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdPut: async (id: string, request: DtoUpdateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesIdPut', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('categoriesIdPut', 'request', request)
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new category with the provided details
         * @summary Create a new category
         * @param {DtoCreateCategoryRequest} request Create category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPost: async (request: DtoCreateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('categoriesPost', 'request', request)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a category by its slug
         * @summary Get category by slug
         * @param {string} slug Category slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesSlugSlugGet: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('categoriesSlugSlugGet', 'slug', slug)
            const localVarPath = `/categories/slug/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a paginated list of categories with filtering and pagination
         * @summary List categories
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [name] Filter by names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, name?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoListCategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesGet(limit, offset, status, sort, order, slug, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft delete a category
         * @summary Delete a category
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a category by its ID
         * @summary Get category by ID
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing category
         * @summary Update a category
         * @param {string} id Category ID
         * @param {DtoUpdateCategoryRequest} request Update category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesIdPut(id: string, request: DtoUpdateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesIdPut(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new category with the provided details
         * @summary Create a new category
         * @param {DtoCreateCategoryRequest} request Create category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesPost(request: DtoCreateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a category by its slug
         * @summary Get category by slug
         * @param {string} slug Category slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesSlugSlugGet(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesSlugSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * Get a paginated list of categories with filtering and pagination
         * @summary List categories
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [name] Filter by names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, name?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<DtoListCategoriesResponse> {
            return localVarFp.categoriesGet(limit, offset, status, sort, order, slug, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft delete a category
         * @summary Delete a category
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.categoriesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a category by its ID
         * @summary Get category by ID
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoCategoryResponse> {
            return localVarFp.categoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing category
         * @summary Update a category
         * @param {string} id Category ID
         * @param {DtoUpdateCategoryRequest} request Update category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdPut(id: string, request: DtoUpdateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoCategoryResponse> {
            return localVarFp.categoriesIdPut(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new category with the provided details
         * @summary Create a new category
         * @param {DtoCreateCategoryRequest} request Create category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPost(request: DtoCreateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoCategoryResponse> {
            return localVarFp.categoriesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a category by its slug
         * @summary Get category by slug
         * @param {string} slug Category slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoCategoryResponse> {
            return localVarFp.categoriesSlugSlugGet(slug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * Get a paginated list of categories with filtering and pagination
     * @summary List categories
     * @param {number} [limit] Limit
     * @param {number} [offset] Offset
     * @param {string} [status] Status
     * @param {string} [sort] Sort field
     * @param {string} [order] Sort order (asc/desc)
     * @param {Array<string>} [slug] Filter by slugs
     * @param {Array<string>} [name] Filter by names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, name?: Array<string>, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesGet(limit, offset, status, sort, order, slug, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft delete a category
     * @summary Delete a category
     * @param {string} id Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a category by its ID
     * @summary Get category by ID
     * @param {string} id Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing category
     * @summary Update a category
     * @param {string} id Category ID
     * @param {DtoUpdateCategoryRequest} request Update category request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesIdPut(id: string, request: DtoUpdateCategoryRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesIdPut(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new category with the provided details
     * @summary Create a new category
     * @param {DtoCreateCategoryRequest} request Create category request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesPost(request: DtoCreateCategoryRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a category by its slug
     * @summary Get category by slug
     * @param {string} slug Category slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesSlugSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeedApi - axios parameter creator
 * @export
 */
export const FeedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get feed data with multiple sections (trending, popular, latest, nearby)
         * @summary Get feed data
         * @param {DtoFeedRequest} request Feed request with sections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedPost: async (request: DtoFeedRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('feedPost', 'request', request)
            const localVarPath = `/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Increment the view count for a specific place
         * @summary Increment view count for a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdViewPost: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdViewPost', 'id', id)
            const localVarPath = `/places/{id}/view`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedApi - functional programming interface
 * @export
 */
export const FeedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedApiAxiosParamCreator(configuration)
    return {
        /**
         * Get feed data with multiple sections (trending, popular, latest, nearby)
         * @summary Get feed data
         * @param {DtoFeedRequest} request Feed request with sections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedPost(request: DtoFeedRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoFeedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedApi.feedPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Increment the view count for a specific place
         * @summary Increment view count for a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdViewPost(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdViewPost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedApi.placesIdViewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedApi - factory interface
 * @export
 */
export const FeedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedApiFp(configuration)
    return {
        /**
         * Get feed data with multiple sections (trending, popular, latest, nearby)
         * @summary Get feed data
         * @param {DtoFeedRequest} request Feed request with sections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedPost(request: DtoFeedRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoFeedResponse> {
            return localVarFp.feedPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Increment the view count for a specific place
         * @summary Increment view count for a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdViewPost(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.placesIdViewPost(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedApi - object-oriented interface
 * @export
 * @class FeedApi
 * @extends {BaseAPI}
 */
export class FeedApi extends BaseAPI {
    /**
     * Get feed data with multiple sections (trending, popular, latest, nearby)
     * @summary Get feed data
     * @param {DtoFeedRequest} request Feed request with sections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public feedPost(request: DtoFeedRequest, options?: RawAxiosRequestConfig) {
        return FeedApiFp(this.configuration).feedPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Increment the view count for a specific place
     * @summary Increment view count for a place
     * @param {string} id Place ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public placesIdViewPost(id: string, options?: RawAxiosRequestConfig) {
        return FeedApiFp(this.configuration).placesIdViewPost(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlaceApi - axios parameter creator
 * @export
 */
export const PlaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a paginated list of places with filtering and pagination
         * @summary List places
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [placeTypes] Filter by place types
         * @param {Array<string>} [categories] Filter by categories
         * @param {Array<string>} [amenities] Filter by amenities
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {number} [latitude] Latitude for geospatial filtering
         * @param {number} [longitude] Longitude for geospatial filtering
         * @param {number} [radiusKm] Radius in kilometers for geospatial filtering
         * @param {string} [searchQuery] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesGet: async (limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, placeTypes?: Array<string>, categories?: Array<string>, amenities?: Array<string>, minRating?: number, maxRating?: number, latitude?: number, longitude?: number, radiusKm?: number, searchQuery?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (slug) {
                localVarQueryParameter['slug'] = slug.join(COLLECTION_FORMATS.csv);
            }

            if (placeTypes) {
                localVarQueryParameter['place_types'] = placeTypes.join(COLLECTION_FORMATS.csv);
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories.join(COLLECTION_FORMATS.csv);
            }

            if (amenities) {
                localVarQueryParameter['amenities'] = amenities.join(COLLECTION_FORMATS.csv);
            }

            if (minRating !== undefined) {
                localVarQueryParameter['min_rating'] = minRating;
            }

            if (maxRating !== undefined) {
                localVarQueryParameter['max_rating'] = maxRating;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (radiusKm !== undefined) {
                localVarQueryParameter['radius_km'] = radiusKm;
            }

            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft delete a place
         * @summary Delete a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdDelete', 'id', id)
            const localVarPath = `/places/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a place by its ID
         * @summary Get place by ID
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdGet', 'id', id)
            const localVarPath = `/places/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all images for a place
         * @summary Get place images
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdImagesGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdImagesGet', 'id', id)
            const localVarPath = `/places/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an image to a place
         * @summary Add image to place
         * @param {string} id Place ID
         * @param {DtoCreatePlaceImageRequest} request Create place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdImagesPost: async (id: string, request: DtoCreatePlaceImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdImagesPost', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('placesIdImagesPost', 'request', request)
            const localVarPath = `/places/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing place
         * @summary Update a place
         * @param {string} id Place ID
         * @param {DtoUpdatePlaceRequest} request Update place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdPut: async (id: string, request: DtoUpdatePlaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdPut', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('placesIdPut', 'request', request)
            const localVarPath = `/places/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a place image
         * @summary Delete place image
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesImagesImageIdDelete: async (imageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('placesImagesImageIdDelete', 'imageId', imageId)
            const localVarPath = `/places/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing place image
         * @summary Update place image
         * @param {string} imageId Image ID
         * @param {DtoUpdatePlaceImageRequest} request Update place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesImagesImageIdPut: async (imageId: string, request: DtoUpdatePlaceImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('placesImagesImageIdPut', 'imageId', imageId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('placesImagesImageIdPut', 'request', request)
            const localVarPath = `/places/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new place with the provided details
         * @summary Create a new place
         * @param {DtoCreatePlaceRequest} request Create place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesPost: async (request: DtoCreatePlaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('placesPost', 'request', request)
            const localVarPath = `/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a place by its slug
         * @summary Get place by slug
         * @param {string} slug Place slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesSlugSlugGet: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('placesSlugSlugGet', 'slug', slug)
            const localVarPath = `/places/slug/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaceApi - functional programming interface
 * @export
 */
export const PlaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a paginated list of places with filtering and pagination
         * @summary List places
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [placeTypes] Filter by place types
         * @param {Array<string>} [categories] Filter by categories
         * @param {Array<string>} [amenities] Filter by amenities
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {number} [latitude] Latitude for geospatial filtering
         * @param {number} [longitude] Longitude for geospatial filtering
         * @param {number} [radiusKm] Radius in kilometers for geospatial filtering
         * @param {string} [searchQuery] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, placeTypes?: Array<string>, categories?: Array<string>, amenities?: Array<string>, minRating?: number, maxRating?: number, latitude?: number, longitude?: number, radiusKm?: number, searchQuery?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoListPlacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesGet(limit, offset, status, sort, order, slug, placeTypes, categories, amenities, minRating, maxRating, latitude, longitude, radiusKm, searchQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft delete a place
         * @summary Delete a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a place by its ID
         * @summary Get place by ID
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all images for a place
         * @summary Get place images
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdImagesGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DtoPlaceImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdImagesGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesIdImagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add an image to a place
         * @summary Add image to place
         * @param {string} id Place ID
         * @param {DtoCreatePlaceImageRequest} request Create place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdImagesPost(id: string, request: DtoCreatePlaceImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdImagesPost(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesIdImagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing place
         * @summary Update a place
         * @param {string} id Place ID
         * @param {DtoUpdatePlaceRequest} request Update place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdPut(id: string, request: DtoUpdatePlaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdPut(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a place image
         * @summary Delete place image
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesImagesImageIdDelete(imageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesImagesImageIdDelete(imageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesImagesImageIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing place image
         * @summary Update place image
         * @param {string} imageId Image ID
         * @param {DtoUpdatePlaceImageRequest} request Update place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesImagesImageIdPut(imageId: string, request: DtoUpdatePlaceImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesImagesImageIdPut(imageId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesImagesImageIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new place with the provided details
         * @summary Create a new place
         * @param {DtoCreatePlaceRequest} request Create place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesPost(request: DtoCreatePlaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a place by its slug
         * @summary Get place by slug
         * @param {string} slug Place slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesSlugSlugGet(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesSlugSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlaceApi - factory interface
 * @export
 */
export const PlaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaceApiFp(configuration)
    return {
        /**
         * Get a paginated list of places with filtering and pagination
         * @summary List places
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [placeTypes] Filter by place types
         * @param {Array<string>} [categories] Filter by categories
         * @param {Array<string>} [amenities] Filter by amenities
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {number} [latitude] Latitude for geospatial filtering
         * @param {number} [longitude] Longitude for geospatial filtering
         * @param {number} [radiusKm] Radius in kilometers for geospatial filtering
         * @param {string} [searchQuery] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, placeTypes?: Array<string>, categories?: Array<string>, amenities?: Array<string>, minRating?: number, maxRating?: number, latitude?: number, longitude?: number, radiusKm?: number, searchQuery?: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoListPlacesResponse> {
            return localVarFp.placesGet(limit, offset, status, sort, order, slug, placeTypes, categories, amenities, minRating, maxRating, latitude, longitude, radiusKm, searchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft delete a place
         * @summary Delete a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.placesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a place by its ID
         * @summary Get place by ID
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceResponse> {
            return localVarFp.placesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all images for a place
         * @summary Get place images
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdImagesGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DtoPlaceImageResponse>> {
            return localVarFp.placesIdImagesGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an image to a place
         * @summary Add image to place
         * @param {string} id Place ID
         * @param {DtoCreatePlaceImageRequest} request Create place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdImagesPost(id: string, request: DtoCreatePlaceImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceImageResponse> {
            return localVarFp.placesIdImagesPost(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing place
         * @summary Update a place
         * @param {string} id Place ID
         * @param {DtoUpdatePlaceRequest} request Update place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdPut(id: string, request: DtoUpdatePlaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceResponse> {
            return localVarFp.placesIdPut(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a place image
         * @summary Delete place image
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesImagesImageIdDelete(imageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.placesImagesImageIdDelete(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing place image
         * @summary Update place image
         * @param {string} imageId Image ID
         * @param {DtoUpdatePlaceImageRequest} request Update place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesImagesImageIdPut(imageId: string, request: DtoUpdatePlaceImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceImageResponse> {
            return localVarFp.placesImagesImageIdPut(imageId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new place with the provided details
         * @summary Create a new place
         * @param {DtoCreatePlaceRequest} request Create place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesPost(request: DtoCreatePlaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceResponse> {
            return localVarFp.placesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a place by its slug
         * @summary Get place by slug
         * @param {string} slug Place slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceResponse> {
            return localVarFp.placesSlugSlugGet(slug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaceApi - object-oriented interface
 * @export
 * @class PlaceApi
 * @extends {BaseAPI}
 */
export class PlaceApi extends BaseAPI {
    /**
     * Get a paginated list of places with filtering and pagination
     * @summary List places
     * @param {number} [limit] Limit
     * @param {number} [offset] Offset
     * @param {string} [status] Status
     * @param {string} [sort] Sort field
     * @param {string} [order] Sort order (asc/desc)
     * @param {Array<string>} [slug] Filter by slugs
     * @param {Array<string>} [placeTypes] Filter by place types
     * @param {Array<string>} [categories] Filter by categories
     * @param {Array<string>} [amenities] Filter by amenities
     * @param {number} [minRating] Minimum rating
     * @param {number} [maxRating] Maximum rating
     * @param {number} [latitude] Latitude for geospatial filtering
     * @param {number} [longitude] Longitude for geospatial filtering
     * @param {number} [radiusKm] Radius in kilometers for geospatial filtering
     * @param {string} [searchQuery] Search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, placeTypes?: Array<string>, categories?: Array<string>, amenities?: Array<string>, minRating?: number, maxRating?: number, latitude?: number, longitude?: number, radiusKm?: number, searchQuery?: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesGet(limit, offset, status, sort, order, slug, placeTypes, categories, amenities, minRating, maxRating, latitude, longitude, radiusKm, searchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft delete a place
     * @summary Delete a place
     * @param {string} id Place ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a place by its ID
     * @summary Get place by ID
     * @param {string} id Place ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all images for a place
     * @summary Get place images
     * @param {string} id Place ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesIdImagesGet(id: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesIdImagesGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an image to a place
     * @summary Add image to place
     * @param {string} id Place ID
     * @param {DtoCreatePlaceImageRequest} request Create place image request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesIdImagesPost(id: string, request: DtoCreatePlaceImageRequest, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesIdImagesPost(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing place
     * @summary Update a place
     * @param {string} id Place ID
     * @param {DtoUpdatePlaceRequest} request Update place request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesIdPut(id: string, request: DtoUpdatePlaceRequest, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesIdPut(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a place image
     * @summary Delete place image
     * @param {string} imageId Image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesImagesImageIdDelete(imageId: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesImagesImageIdDelete(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing place image
     * @summary Update place image
     * @param {string} imageId Image ID
     * @param {DtoUpdatePlaceImageRequest} request Update place image request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesImagesImageIdPut(imageId: string, request: DtoUpdatePlaceImageRequest, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesImagesImageIdPut(imageId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new place with the provided details
     * @summary Create a new place
     * @param {DtoCreatePlaceRequest} request Create place request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesPost(request: DtoCreatePlaceRequest, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a place by its slug
     * @summary Get place by slug
     * @param {string} slug Place slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesSlugSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReviewsApi - axios parameter creator
 * @export
 */
export const ReviewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a paginated list of reviews with filtering
         * @summary List reviews
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [entityType] Entity type (place, experience, etc.)
         * @param {string} [entityId] Entity ID
         * @param {string} [userId] User ID
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsGet: async (limit?: number, offset?: number, entityType?: string, entityId?: string, userId?: string, minRating?: number, maxRating?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entity_type'] = entityType;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entity_id'] = entityId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (minRating !== undefined) {
                localVarQueryParameter['min_rating'] = minRating;
            }

            if (maxRating !== undefined) {
                localVarQueryParameter['max_rating'] = maxRating;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a review
         * @summary Delete a review
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reviewsIdDelete', 'id', id)
            const localVarPath = `/reviews/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a review by its ID
         * @summary Get review by ID
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reviewsIdGet', 'id', id)
            const localVarPath = `/reviews/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing review
         * @summary Update a review
         * @param {string} id Review ID
         * @param {DtoUpdateReviewRequest} request Update review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdPut: async (id: string, request: DtoUpdateReviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reviewsIdPut', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('reviewsIdPut', 'request', request)
            const localVarPath = `/reviews/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new review for a place or other entity
         * @summary Create a new review
         * @param {DtoCreateReviewRequest} request Create review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsPost: async (request: DtoCreateReviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('reviewsPost', 'request', request)
            const localVarPath = `/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get rating statistics for an entity (place, experience, etc.)
         * @summary Get rating statistics
         * @param {string} entityType Entity type (place, experience, etc.)
         * @param {string} entityId Entity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsStatsEntityTypeEntityIdGet: async (entityType: string, entityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('reviewsStatsEntityTypeEntityIdGet', 'entityType', entityType)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('reviewsStatsEntityTypeEntityIdGet', 'entityId', entityId)
            const localVarPath = `/reviews/stats/{entityType}/{entityId}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewsApi - functional programming interface
 * @export
 */
export const ReviewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a paginated list of reviews with filtering
         * @summary List reviews
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [entityType] Entity type (place, experience, etc.)
         * @param {string} [entityId] Entity ID
         * @param {string} [userId] User ID
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsGet(limit?: number, offset?: number, entityType?: string, entityId?: string, userId?: string, minRating?: number, maxRating?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesListResponseDtoReviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsGet(limit, offset, entityType, entityId, userId, minRating, maxRating, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a review
         * @summary Delete a review
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a review by its ID
         * @summary Get review by ID
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoReviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing review
         * @summary Update a review
         * @param {string} id Review ID
         * @param {DtoUpdateReviewRequest} request Update review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsIdPut(id: string, request: DtoUpdateReviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoReviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsIdPut(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new review for a place or other entity
         * @summary Create a new review
         * @param {DtoCreateReviewRequest} request Create review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsPost(request: DtoCreateReviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoReviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get rating statistics for an entity (place, experience, etc.)
         * @summary Get rating statistics
         * @param {string} entityType Entity type (place, experience, etc.)
         * @param {string} entityId Entity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsStatsEntityTypeEntityIdGet(entityType: string, entityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoRatingStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsStatsEntityTypeEntityIdGet(entityType, entityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsStatsEntityTypeEntityIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReviewsApi - factory interface
 * @export
 */
export const ReviewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewsApiFp(configuration)
    return {
        /**
         * Get a paginated list of reviews with filtering
         * @summary List reviews
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [entityType] Entity type (place, experience, etc.)
         * @param {string} [entityId] Entity ID
         * @param {string} [userId] User ID
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsGet(limit?: number, offset?: number, entityType?: string, entityId?: string, userId?: string, minRating?: number, maxRating?: number, options?: RawAxiosRequestConfig): AxiosPromise<TypesListResponseDtoReviewResponse> {
            return localVarFp.reviewsGet(limit, offset, entityType, entityId, userId, minRating, maxRating, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a review
         * @summary Delete a review
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.reviewsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a review by its ID
         * @summary Get review by ID
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoReviewResponse> {
            return localVarFp.reviewsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing review
         * @summary Update a review
         * @param {string} id Review ID
         * @param {DtoUpdateReviewRequest} request Update review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdPut(id: string, request: DtoUpdateReviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoReviewResponse> {
            return localVarFp.reviewsIdPut(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new review for a place or other entity
         * @summary Create a new review
         * @param {DtoCreateReviewRequest} request Create review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsPost(request: DtoCreateReviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoReviewResponse> {
            return localVarFp.reviewsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get rating statistics for an entity (place, experience, etc.)
         * @summary Get rating statistics
         * @param {string} entityType Entity type (place, experience, etc.)
         * @param {string} entityId Entity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsStatsEntityTypeEntityIdGet(entityType: string, entityId: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoRatingStatsResponse> {
            return localVarFp.reviewsStatsEntityTypeEntityIdGet(entityType, entityId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReviewsApi - object-oriented interface
 * @export
 * @class ReviewsApi
 * @extends {BaseAPI}
 */
export class ReviewsApi extends BaseAPI {
    /**
     * Get a paginated list of reviews with filtering
     * @summary List reviews
     * @param {number} [limit] Limit
     * @param {number} [offset] Offset
     * @param {string} [entityType] Entity type (place, experience, etc.)
     * @param {string} [entityId] Entity ID
     * @param {string} [userId] User ID
     * @param {number} [minRating] Minimum rating
     * @param {number} [maxRating] Maximum rating
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsGet(limit?: number, offset?: number, entityType?: string, entityId?: string, userId?: string, minRating?: number, maxRating?: number, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsGet(limit, offset, entityType, entityId, userId, minRating, maxRating, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a review
     * @summary Delete a review
     * @param {string} id Review ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a review by its ID
     * @summary Get review by ID
     * @param {string} id Review ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing review
     * @summary Update a review
     * @param {string} id Review ID
     * @param {DtoUpdateReviewRequest} request Update review request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsIdPut(id: string, request: DtoUpdateReviewRequest, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsIdPut(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new review for a place or other entity
     * @summary Create a new review
     * @param {DtoCreateReviewRequest} request Create review request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsPost(request: DtoCreateReviewRequest, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get rating statistics for an entity (place, experience, etc.)
     * @summary Get rating statistics
     * @param {string} entityType Entity type (place, experience, etc.)
     * @param {string} entityId Entity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsStatsEntityTypeEntityIdGet(entityType: string, entityId: string, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsStatsEntityTypeEntityIdGet(entityType, entityId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the current user\'s information
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the current user\'s information
         * @summary Update current user
         * @param {DtoUpdateUserRequest} request Update user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPut: async (request: DtoUpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('userPut', 'request', request)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the current user\'s information
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoMeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the current user\'s information
         * @summary Update current user
         * @param {DtoUpdateUserRequest} request Update user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPut(request: DtoUpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoMeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPut(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Get the current user\'s information
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeGet(options?: RawAxiosRequestConfig): AxiosPromise<DtoMeResponse> {
            return localVarFp.userMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the current user\'s information
         * @summary Update current user
         * @param {DtoUpdateUserRequest} request Update user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPut(request: DtoUpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoMeResponse> {
            return localVarFp.userPut(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Get the current user\'s information
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userMeGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the current user\'s information
     * @summary Update current user
     * @param {DtoUpdateUserRequest} request Update user request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPut(request: DtoUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userPut(request, options).then((request) => request(this.axios, this.basePath));
    }
}




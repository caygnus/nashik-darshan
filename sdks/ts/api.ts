/* tslint:disable */
/* eslint-disable */
/**
 * Nashik Darshan API
 * API for Nashik Darshan
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@nashikdarshan.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface DtoCategoryResponse
 */
export interface DtoCategoryResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoCategoryResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'slug'?: string;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoCategoryResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCategoryResponse
     */
    'updated_by'?: string;
}


/**
 * 
 * @export
 * @interface DtoCreateCategoryRequest
 */
export interface DtoCreateCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoCreateCategoryRequest
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoCreateCategoryRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoCreateCategoryRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateCategoryRequest
     */
    'slug': string;
}
/**
 * 
 * @export
 * @interface DtoCreateEventRequest
 */
export interface DtoCreateEventRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoCreateEventRequest
     */
    'cover_image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateEventRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateEventRequest
     */
    'end_date'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoCreateEventRequest
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoCreateEventRequest
     */
    'latitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateEventRequest
     */
    'location_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoCreateEventRequest
     */
    'longitude'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoCreateEventRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoCreateEventRequest
     */
    'place_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateEventRequest
     */
    'slug': string;
    /**
     * Required, defaults to now() if zero value
     * @type {string}
     * @memberof DtoCreateEventRequest
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateEventRequest
     */
    'subtitle'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoCreateEventRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateEventRequest
     */
    'title': string;
    /**
     * 
     * @type {TypesEventType}
     * @memberof DtoCreateEventRequest
     */
    'type': TypesEventType;
}


/**
 * 
 * @export
 * @interface DtoCreateHotelRequest
 */
export interface DtoCreateHotelRequest {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoCreateHotelRequest
     */
    'address'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoCreateHotelRequest
     */
    'check_in_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateHotelRequest
     */
    'check_out_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateHotelRequest
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateHotelRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateHotelRequest
     */
    'email'?: string;
    /**
     * 
     * @type {TypesLocation}
     * @memberof DtoCreateHotelRequest
     */
    'location': TypesLocation;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateHotelRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateHotelRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoCreateHotelRequest
     */
    'price_max'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoCreateHotelRequest
     */
    'price_min'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateHotelRequest
     */
    'primary_image_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoCreateHotelRequest
     */
    'room_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateHotelRequest
     */
    'slug': string;
    /**
     * 
     * @type {number}
     * @memberof DtoCreateHotelRequest
     */
    'star_rating': number;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateHotelRequest
     */
    'thumbnail_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateHotelRequest
     */
    'website'?: string;
}
/**
 * 
 * @export
 * @interface DtoCreateOccurrenceRequest
 */
export interface DtoCreateOccurrenceRequest {
    /**
     * 1-31 for MONTHLY/YEARLY
     * @type {number}
     * @memberof DtoCreateOccurrenceRequest
     */
    'day_of_month'?: number;
    /**
     * 0-6 for WEEKLY
     * @type {number}
     * @memberof DtoCreateOccurrenceRequest
     */
    'day_of_week'?: number;
    /**
     * ISO 8601 format, optional/nillable
     * @type {string}
     * @memberof DtoCreateOccurrenceRequest
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateOccurrenceRequest
     */
    'event_id': string;
    /**
     * [\"2025-12-25\", ...]
     * @type {Array<string>}
     * @memberof DtoCreateOccurrenceRequest
     */
    'exception_dates'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoCreateOccurrenceRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 1-12 for YEARLY
     * @type {number}
     * @memberof DtoCreateOccurrenceRequest
     */
    'month_of_year'?: number;
    /**
     * 
     * @type {TypesRecurrenceType}
     * @memberof DtoCreateOccurrenceRequest
     */
    'recurrence_type': TypesRecurrenceType;
    /**
     * ISO 8601 format, optional/nillable
     * @type {string}
     * @memberof DtoCreateOccurrenceRequest
     */
    'start_time'?: string;
}


/**
 * 
 * @export
 * @interface DtoCreatePlaceImageRequest
 */
export interface DtoCreatePlaceImageRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceImageRequest
     */
    'alt'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoCreatePlaceImageRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof DtoCreatePlaceImageRequest
     */
    'pos'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceImageRequest
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface DtoCreatePlaceRequest
 */
export interface DtoCreatePlaceRequest {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoCreatePlaceRequest
     */
    'address'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoCreatePlaceRequest
     */
    'amenities'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoCreatePlaceRequest
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {TypesLocation}
     * @memberof DtoCreatePlaceRequest
     */
    'location': TypesLocation;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'long_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'place_type': string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'primary_image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'short_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'subtitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'thumbnail_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreatePlaceRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface DtoCreateReviewRequest
 */
export interface DtoCreateReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoCreateReviewRequest
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateReviewRequest
     */
    'entity_id': string;
    /**
     * 
     * @type {TypesReviewEntityType}
     * @memberof DtoCreateReviewRequest
     */
    'entity_type': TypesReviewEntityType;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoCreateReviewRequest
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoCreateReviewRequest
     */
    'rating': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoCreateReviewRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoCreateReviewRequest
     */
    'title'?: string;
}


/**
 * 
 * @export
 * @interface DtoEventResponse
 */
export interface DtoEventResponse {
    /**
     * Media
     * @type {string}
     * @memberof DtoEventResponse
     */
    'cover_image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoEventResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoEventResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoEventResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoEventResponse
     */
    'end_date'?: string;
    /**
     * Identity
     * @type {string}
     * @memberof DtoEventResponse
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoEventResponse
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoEventResponse
     */
    'interested_count'?: number;
    /**
     * Location (for citywide)
     * @type {number}
     * @memberof DtoEventResponse
     */
    'latitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoEventResponse
     */
    'location_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoEventResponse
     */
    'longitude'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoEventResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Relations (populated when needed)
     * @type {Array<EventEventOccurrence>}
     * @memberof DtoEventResponse
     */
    'occurrences'?: Array<EventEventOccurrence>;
    /**
     * Association
     * @type {string}
     * @memberof DtoEventResponse
     */
    'place_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoEventResponse
     */
    'slug'?: string;
    /**
     * Validity
     * @type {string}
     * @memberof DtoEventResponse
     */
    'start_date'?: string;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoEventResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof DtoEventResponse
     */
    'subtitle'?: string;
    /**
     * Metadata
     * @type {Array<string>}
     * @memberof DtoEventResponse
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoEventResponse
     */
    'title'?: string;
    /**
     * Core
     * @type {TypesEventType}
     * @memberof DtoEventResponse
     */
    'type'?: TypesEventType;
    /**
     * 
     * @type {string}
     * @memberof DtoEventResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoEventResponse
     */
    'updated_by'?: string;
    /**
     * Stats
     * @type {number}
     * @memberof DtoEventResponse
     */
    'view_count'?: number;
}


/**
 * 
 * @export
 * @interface DtoFeedRequest
 */
export interface DtoFeedRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoFeedRequest
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedRequest
     */
    'expand'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedRequest
     */
    'offset'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedRequest
     */
    'order'?: DtoFeedRequestOrderEnum;
    /**
     * 
     * @type {Array<DtoFeedSectionRequest>}
     * @memberof DtoFeedRequest
     */
    'sections': Array<DtoFeedSectionRequest>;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedRequest
     */
    'sort'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedRequest
     */
    'start_time'?: string;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoFeedRequest
     */
    'status'?: TypesStatus;
}

export const DtoFeedRequestOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type DtoFeedRequestOrderEnum = typeof DtoFeedRequestOrderEnum[keyof typeof DtoFeedRequestOrderEnum];

/**
 * 
 * @export
 * @interface DtoFeedResponse
 */
export interface DtoFeedResponse {
    /**
     * 
     * @type {Array<DtoFeedSectionResponse>}
     * @memberof DtoFeedResponse
     */
    'sections'?: Array<DtoFeedSectionResponse>;
}
/**
 * 
 * @export
 * @interface DtoFeedSectionRequest
 */
export interface DtoFeedSectionRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoFeedSectionRequest
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedSectionRequest
     */
    'expand'?: string;
    /**
     * Geospatial fields (for nearby section)
     * @type {number}
     * @memberof DtoFeedSectionRequest
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedSectionRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedSectionRequest
     */
    'longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedSectionRequest
     */
    'offset'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedSectionRequest
     */
    'order'?: DtoFeedSectionRequestOrderEnum;
    /**
     * 
     * @type {number}
     * @memberof DtoFeedSectionRequest
     */
    'radius_km'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedSectionRequest
     */
    'sort'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoFeedSectionRequest
     */
    'start_time'?: string;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoFeedSectionRequest
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {TypesFeedSectionType}
     * @memberof DtoFeedSectionRequest
     */
    'type': TypesFeedSectionType;
}

export const DtoFeedSectionRequestOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type DtoFeedSectionRequestOrderEnum = typeof DtoFeedSectionRequestOrderEnum[keyof typeof DtoFeedSectionRequestOrderEnum];

/**
 * 
 * @export
 * @interface DtoFeedSectionResponse
 */
export interface DtoFeedSectionResponse {
    /**
     * 
     * @type {Array<DtoPlaceResponse>}
     * @memberof DtoFeedSectionResponse
     */
    'items'?: Array<DtoPlaceResponse>;
    /**
     * 
     * @type {TypesPaginationResponse}
     * @memberof DtoFeedSectionResponse
     */
    'pagination'?: TypesPaginationResponse;
    /**
     * 
     * @type {TypesFeedSectionType}
     * @memberof DtoFeedSectionResponse
     */
    'type'?: TypesFeedSectionType;
}


/**
 * 
 * @export
 * @interface DtoHotelResponse
 */
export interface DtoHotelResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoHotelResponse
     */
    'address'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'check_in_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'check_out_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'last_viewed_at'?: string;
    /**
     * 
     * @type {TypesLocation}
     * @memberof DtoHotelResponse
     */
    'location'?: TypesLocation;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoHotelResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'phone'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoHotelResponse
     */
    'popularity_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoHotelResponse
     */
    'price_max'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoHotelResponse
     */
    'price_min'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'primary_image_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoHotelResponse
     */
    'rating_avg'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoHotelResponse
     */
    'rating_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoHotelResponse
     */
    'room_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'slug'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoHotelResponse
     */
    'star_rating'?: number;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoHotelResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'thumbnail_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'updated_by'?: string;
    /**
     * Engagement fields
     * @type {number}
     * @memberof DtoHotelResponse
     */
    'view_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoHotelResponse
     */
    'website'?: string;
}


/**
 * 
 * @export
 * @interface DtoListCategoriesResponse
 */
export interface DtoListCategoriesResponse {
    /**
     * 
     * @type {Array<DtoCategoryResponse>}
     * @memberof DtoListCategoriesResponse
     */
    'items'?: Array<DtoCategoryResponse>;
    /**
     * 
     * @type {TypesPaginationResponse}
     * @memberof DtoListCategoriesResponse
     */
    'pagination'?: TypesPaginationResponse;
}
/**
 * 
 * @export
 * @interface DtoListEventsResponse
 */
export interface DtoListEventsResponse {
    /**
     * 
     * @type {Array<DtoEventResponse>}
     * @memberof DtoListEventsResponse
     */
    'items'?: Array<DtoEventResponse>;
    /**
     * 
     * @type {TypesPaginationResponse}
     * @memberof DtoListEventsResponse
     */
    'pagination'?: TypesPaginationResponse;
}
/**
 * 
 * @export
 * @interface DtoListHotelsResponse
 */
export interface DtoListHotelsResponse {
    /**
     * 
     * @type {Array<DtoHotelResponse>}
     * @memberof DtoListHotelsResponse
     */
    'items'?: Array<DtoHotelResponse>;
    /**
     * 
     * @type {TypesPaginationResponse}
     * @memberof DtoListHotelsResponse
     */
    'pagination'?: TypesPaginationResponse;
}
/**
 * 
 * @export
 * @interface DtoListPlacesResponse
 */
export interface DtoListPlacesResponse {
    /**
     * 
     * @type {Array<DtoPlaceResponse>}
     * @memberof DtoListPlacesResponse
     */
    'items'?: Array<DtoPlaceResponse>;
    /**
     * 
     * @type {TypesPaginationResponse}
     * @memberof DtoListPlacesResponse
     */
    'pagination'?: TypesPaginationResponse;
}
/**
 * 
 * @export
 * @interface DtoMeResponse
 */
export interface DtoMeResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoMeResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'phone'?: string;
    /**
     * 
     * @type {TypesUserRole}
     * @memberof DtoMeResponse
     */
    'role'?: TypesUserRole;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoMeResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoMeResponse
     */
    'updated_by'?: string;
}


/**
 * 
 * @export
 * @interface DtoOccurrenceResponse
 */
export interface DtoOccurrenceResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoOccurrenceResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoOccurrenceResponse
     */
    'created_by'?: string;
    /**
     * 1-31
     * @type {number}
     * @memberof DtoOccurrenceResponse
     */
    'day_of_month'?: number;
    /**
     * Day specifics
     * @type {number}
     * @memberof DtoOccurrenceResponse
     */
    'day_of_week'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOccurrenceResponse
     */
    'duration_minutes'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoOccurrenceResponse
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoOccurrenceResponse
     */
    'event_id'?: string;
    /**
     * Exceptions
     * @type {Array<string>}
     * @memberof DtoOccurrenceResponse
     */
    'exception_dates'?: Array<string>;
    /**
     * Identity
     * @type {string}
     * @memberof DtoOccurrenceResponse
     */
    'id'?: string;
    /**
     * Metadata
     * @type {{ [key: string]: string; }}
     * @memberof DtoOccurrenceResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 1-12 (renamed from Month)
     * @type {number}
     * @memberof DtoOccurrenceResponse
     */
    'month_of_year'?: number;
    /**
     * Recurrence
     * @type {TypesRecurrenceType}
     * @memberof DtoOccurrenceResponse
     */
    'recurrence_type'?: TypesRecurrenceType;
    /**
     * Time
     * @type {string}
     * @memberof DtoOccurrenceResponse
     */
    'start_time'?: string;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoOccurrenceResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof DtoOccurrenceResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoOccurrenceResponse
     */
    'updated_by'?: string;
}


/**
 * 
 * @export
 * @interface DtoPlaceImageResponse
 */
export interface DtoPlaceImageResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'alt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoPlaceImageResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'place_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoPlaceImageResponse
     */
    'pos'?: number;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoPlaceImageResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceImageResponse
     */
    'url'?: string;
}


/**
 * 
 * @export
 * @interface DtoPlaceResponse
 */
export interface DtoPlaceResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoPlaceResponse
     */
    'address'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoPlaceResponse
     */
    'amenities'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoPlaceResponse
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'id'?: string;
    /**
     * 
     * @type {Array<DtoPlaceImageResponse>}
     * @memberof DtoPlaceResponse
     */
    'images'?: Array<DtoPlaceImageResponse>;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'last_viewed_at'?: string;
    /**
     * 
     * @type {TypesLocation}
     * @memberof DtoPlaceResponse
     */
    'location'?: TypesLocation;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'long_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'place_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoPlaceResponse
     */
    'popularity_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'primary_image_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoPlaceResponse
     */
    'rating_avg'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoPlaceResponse
     */
    'rating_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'short_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'slug'?: string;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoPlaceResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'subtitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'thumbnail_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoPlaceResponse
     */
    'updated_by'?: string;
    /**
     * Engagement fields for feed functionality
     * @type {number}
     * @memberof DtoPlaceResponse
     */
    'view_count'?: number;
}


/**
 * 
 * @export
 * @interface DtoRatingStatsResponse
 */
export interface DtoRatingStatsResponse {
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'average_rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoRatingStatsResponse
     */
    'entity_id'?: string;
    /**
     * 
     * @type {TypesReviewEntityType}
     * @memberof DtoRatingStatsResponse
     */
    'entity_type'?: TypesReviewEntityType;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'five_star_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'four_star_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'one_star_count'?: number;
    /**
     * rating -> count
     * @type {{ [key: string]: number; }}
     * @memberof DtoRatingStatsResponse
     */
    'rating_distribution'?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'reviews_with_content'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'reviews_with_images'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'three_star_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'total_reviews'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'two_star_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoRatingStatsResponse
     */
    'verified_reviews'?: number;
}


/**
 * 
 * @export
 * @interface DtoReviewResponse
 */
export interface DtoReviewResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'entity_id'?: string;
    /**
     * 
     * @type {TypesReviewEntityType}
     * @memberof DtoReviewResponse
     */
    'entity_type'?: TypesReviewEntityType;
    /**
     * 
     * @type {number}
     * @memberof DtoReviewResponse
     */
    'helpful_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoReviewResponse
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof DtoReviewResponse
     */
    'is_featured'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DtoReviewResponse
     */
    'is_verified'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DtoReviewResponse
     */
    'not_helpful_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoReviewResponse
     */
    'rating'?: number;
    /**
     * 
     * @type {TypesStatus}
     * @memberof DtoReviewResponse
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoReviewResponse
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReviewResponse
     */
    'user_id'?: string;
}


/**
 * 
 * @export
 * @interface DtoSignupRequest
 */
export interface DtoSignupRequest {
    /**
     * access token
     * @type {string}
     * @memberof DtoSignupRequest
     */
    'access_token': string;
    /**
     * basic info
     * @type {string}
     * @memberof DtoSignupRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof DtoSignupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DtoSignupRequest
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface DtoSignupResponse
 */
export interface DtoSignupResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoSignupResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoSignupResponse
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface DtoUpdateCategoryRequest
 */
export interface DtoUpdateCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateCategoryRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateCategoryRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateCategoryRequest
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface DtoUpdateEventRequest
 */
export interface DtoUpdateEventRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateEventRequest
     */
    'cover_image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateEventRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateEventRequest
     */
    'end_date'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoUpdateEventRequest
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoUpdateEventRequest
     */
    'latitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateEventRequest
     */
    'location_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoUpdateEventRequest
     */
    'longitude'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoUpdateEventRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateEventRequest
     */
    'place_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateEventRequest
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateEventRequest
     */
    'subtitle'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoUpdateEventRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateEventRequest
     */
    'title'?: string;
    /**
     * 
     * @type {TypesEventType}
     * @memberof DtoUpdateEventRequest
     */
    'type'?: TypesEventType;
}


/**
 * 
 * @export
 * @interface DtoUpdateHotelRequest
 */
export interface DtoUpdateHotelRequest {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoUpdateHotelRequest
     */
    'address'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateHotelRequest
     */
    'check_in_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateHotelRequest
     */
    'check_out_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateHotelRequest
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateHotelRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateHotelRequest
     */
    'email'?: string;
    /**
     * 
     * @type {TypesLocation}
     * @memberof DtoUpdateHotelRequest
     */
    'location'?: TypesLocation;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateHotelRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateHotelRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoUpdateHotelRequest
     */
    'price_max'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoUpdateHotelRequest
     */
    'price_min'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateHotelRequest
     */
    'primary_image_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoUpdateHotelRequest
     */
    'room_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoUpdateHotelRequest
     */
    'star_rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateHotelRequest
     */
    'thumbnail_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateHotelRequest
     */
    'website'?: string;
}
/**
 * 
 * @export
 * @interface DtoUpdateOccurrenceRequest
 */
export interface DtoUpdateOccurrenceRequest {
    /**
     * 
     * @type {number}
     * @memberof DtoUpdateOccurrenceRequest
     */
    'day_of_month'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoUpdateOccurrenceRequest
     */
    'day_of_week'?: number;
    /**
     * ISO 8601 format, optional/nillable
     * @type {string}
     * @memberof DtoUpdateOccurrenceRequest
     */
    'end_time'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoUpdateOccurrenceRequest
     */
    'exception_dates'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoUpdateOccurrenceRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof DtoUpdateOccurrenceRequest
     */
    'month_of_year'?: number;
    /**
     * 
     * @type {TypesRecurrenceType}
     * @memberof DtoUpdateOccurrenceRequest
     */
    'recurrence_type'?: TypesRecurrenceType;
    /**
     * ISO 8601 format, optional/nillable
     * @type {string}
     * @memberof DtoUpdateOccurrenceRequest
     */
    'start_time'?: string;
}


/**
 * 
 * @export
 * @interface DtoUpdatePlaceImageRequest
 */
export interface DtoUpdatePlaceImageRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceImageRequest
     */
    'alt'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoUpdatePlaceImageRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof DtoUpdatePlaceImageRequest
     */
    'pos'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceImageRequest
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface DtoUpdatePlaceRequest
 */
export interface DtoUpdatePlaceRequest {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoUpdatePlaceRequest
     */
    'address'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoUpdatePlaceRequest
     */
    'amenities'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoUpdatePlaceRequest
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {TypesLocation}
     * @memberof DtoUpdatePlaceRequest
     */
    'location'?: TypesLocation;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'long_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'place_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'primary_image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'short_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'subtitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'thumbnail_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdatePlaceRequest
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface DtoUpdateReviewRequest
 */
export interface DtoUpdateReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateReviewRequest
     */
    'content'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoUpdateReviewRequest
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoUpdateReviewRequest
     */
    'rating'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoUpdateReviewRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateReviewRequest
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface DtoUpdateUserRequest
 */
export interface DtoUpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateUserRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUpdateUserRequest
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface EventEventOccurrence
 */
export interface EventEventOccurrence {
    /**
     * 
     * @type {string}
     * @memberof EventEventOccurrence
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventEventOccurrence
     */
    'created_by'?: string;
    /**
     * 1-31
     * @type {number}
     * @memberof EventEventOccurrence
     */
    'day_of_month'?: number;
    /**
     * Day specifics
     * @type {number}
     * @memberof EventEventOccurrence
     */
    'day_of_week'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventEventOccurrence
     */
    'duration_minutes'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventEventOccurrence
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventEventOccurrence
     */
    'event_id'?: string;
    /**
     * Exceptions
     * @type {Array<string>}
     * @memberof EventEventOccurrence
     */
    'exception_dates'?: Array<string>;
    /**
     * Identity
     * @type {string}
     * @memberof EventEventOccurrence
     */
    'id'?: string;
    /**
     * Metadata
     * @type {{ [key: string]: string; }}
     * @memberof EventEventOccurrence
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 1-12 (renamed from Month)
     * @type {number}
     * @memberof EventEventOccurrence
     */
    'month_of_year'?: number;
    /**
     * Recurrence
     * @type {TypesRecurrenceType}
     * @memberof EventEventOccurrence
     */
    'recurrence_type'?: TypesRecurrenceType;
    /**
     * Time
     * @type {string}
     * @memberof EventEventOccurrence
     */
    'start_time'?: string;
    /**
     * 
     * @type {TypesStatus}
     * @memberof EventEventOccurrence
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof EventEventOccurrence
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventEventOccurrence
     */
    'updated_by'?: string;
}


/**
 * 
 * @export
 * @interface IerrErrorDetail
 */
export interface IerrErrorDetail {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof IerrErrorDetail
     */
    'details'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof IerrErrorDetail
     */
    'internal_error'?: string;
    /**
     * 
     * @type {string}
     * @memberof IerrErrorDetail
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface IerrErrorResponse
 */
export interface IerrErrorResponse {
    /**
     * 
     * @type {IerrErrorDetail}
     * @memberof IerrErrorResponse
     */
    'error'?: IerrErrorDetail;
    /**
     * 
     * @type {boolean}
     * @memberof IerrErrorResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface PlacePlaceImage
 */
export interface PlacePlaceImage {
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'alt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PlacePlaceImage
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'place_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlacePlaceImage
     */
    'pos'?: number;
    /**
     * 
     * @type {TypesStatus}
     * @memberof PlacePlaceImage
     */
    'status'?: TypesStatus;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlacePlaceImage
     */
    'url'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TypesEventType = {
    EventTypeAarti: 'AARTI',
    EventTypeFestival: 'FESTIVAL',
    EventTypeCultural: 'CULTURAL',
    EventTypeWorkshop: 'WORKSHOP',
    EventTypeSpecialDarshan: 'SPECIAL_DARSHAN'
} as const;

export type TypesEventType = typeof TypesEventType[keyof typeof TypesEventType];


/**
 * 
 * @export
 * @enum {string}
 */

export const TypesFeedSectionType = {
    SectionTypeLatest: 'latest',
    SectionTypeTrending: 'trending',
    SectionTypePopular: 'popular',
    SectionTypeNearby: 'nearby'
} as const;

export type TypesFeedSectionType = typeof TypesFeedSectionType[keyof typeof TypesFeedSectionType];


/**
 * 
 * @export
 * @interface TypesListResponseDtoReviewResponse
 */
export interface TypesListResponseDtoReviewResponse {
    /**
     * 
     * @type {Array<DtoReviewResponse>}
     * @memberof TypesListResponseDtoReviewResponse
     */
    'items'?: Array<DtoReviewResponse>;
    /**
     * 
     * @type {TypesPaginationResponse}
     * @memberof TypesListResponseDtoReviewResponse
     */
    'pagination'?: TypesPaginationResponse;
}
/**
 * 
 * @export
 * @interface TypesLocation
 */
export interface TypesLocation {
    /**
     * 
     * @type {number}
     * @memberof TypesLocation
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof TypesLocation
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface TypesPaginationResponse
 */
export interface TypesPaginationResponse {
    /**
     * 
     * @type {number}
     * @memberof TypesPaginationResponse
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof TypesPaginationResponse
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof TypesPaginationResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TypesRecurrenceType = {
    /**
    * One-time event
    */
    RecurrenceNone: 'NONE',
    /**
    * Every day
    */
    RecurrenceDaily: 'DAILY',
    /**
    * Specific day each week
    */
    RecurrenceWeekly: 'WEEKLY',
    /**
    * Specific date each month
    */
    RecurrenceMonthly: 'MONTHLY',
    /**
    * Specific date each year
    */
    RecurrenceYearly: 'YEARLY'
} as const;

export type TypesRecurrenceType = typeof TypesRecurrenceType[keyof typeof TypesRecurrenceType];


/**
 * 
 * @export
 * @enum {string}
 */

export const TypesReviewEntityType = {
    EntityTypePlace: 'place',
    EntityTypeHotel: 'hotel',
    EntityTypeRestaurant: 'restaurant',
    EntityTypeEvent: 'event',
    EntityTypeExperience: 'experience',
    EntityTypeAttraction: 'attraction'
} as const;

export type TypesReviewEntityType = typeof TypesReviewEntityType[keyof typeof TypesReviewEntityType];


/**
 * 
 * @export
 * @enum {string}
 */

export const TypesStatus = {
    StatusPublished: 'published',
    StatusDeleted: 'deleted',
    StatusArchived: 'archived',
    StatusInactive: 'inactive',
    StatusPending: 'pending',
    StatusDraft: 'draft'
} as const;

export type TypesStatus = typeof TypesStatus[keyof typeof TypesStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const TypesUserRole = {
    UserRoleUser: 'USER',
    UserRoleAdmin: 'ADMIN'
} as const;

export type TypesUserRole = typeof TypesUserRole[keyof typeof TypesUserRole];



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Signup
         * @summary Signup
         * @param {DtoSignupRequest} signupRequest Signup request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignupPost: async (signupRequest: DtoSignupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequest' is not null or undefined
            assertParamExists('authSignupPost', 'signupRequest', signupRequest)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Signup
         * @summary Signup
         * @param {DtoSignupRequest} signupRequest Signup request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSignupPost(signupRequest: DtoSignupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoSignupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSignupPost(signupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authSignupPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Signup
         * @summary Signup
         * @param {DtoSignupRequest} signupRequest Signup request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignupPost(signupRequest: DtoSignupRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoSignupResponse> {
            return localVarFp.authSignupPost(signupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Signup
     * @summary Signup
     * @param {DtoSignupRequest} signupRequest Signup request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSignupPost(signupRequest: DtoSignupRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSignupPost(signupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a paginated list of categories with filtering and pagination
         * @summary List categories
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [name] Filter by names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesGet: async (limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, name?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (slug) {
                localVarQueryParameter['slug'] = slug.join(COLLECTION_FORMATS.csv);
            }

            if (name) {
                localVarQueryParameter['name'] = name.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft delete a category
         * @summary Delete a category
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesIdDelete', 'id', id)
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a category by its ID
         * @summary Get category by ID
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesIdGet', 'id', id)
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing category
         * @summary Update a category
         * @param {string} id Category ID
         * @param {DtoUpdateCategoryRequest} request Update category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdPut: async (id: string, request: DtoUpdateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesIdPut', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('categoriesIdPut', 'request', request)
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new category with the provided details
         * @summary Create a new category
         * @param {DtoCreateCategoryRequest} request Create category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPost: async (request: DtoCreateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('categoriesPost', 'request', request)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a category by its slug
         * @summary Get category by slug
         * @param {string} slug Category slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesSlugSlugGet: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('categoriesSlugSlugGet', 'slug', slug)
            const localVarPath = `/categories/slug/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a paginated list of categories with filtering and pagination
         * @summary List categories
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [name] Filter by names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, name?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoListCategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesGet(limit, offset, status, sort, order, slug, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft delete a category
         * @summary Delete a category
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a category by its ID
         * @summary Get category by ID
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing category
         * @summary Update a category
         * @param {string} id Category ID
         * @param {DtoUpdateCategoryRequest} request Update category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesIdPut(id: string, request: DtoUpdateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesIdPut(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new category with the provided details
         * @summary Create a new category
         * @param {DtoCreateCategoryRequest} request Create category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesPost(request: DtoCreateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a category by its slug
         * @summary Get category by slug
         * @param {string} slug Category slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesSlugSlugGet(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoriesSlugSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * Get a paginated list of categories with filtering and pagination
         * @summary List categories
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [name] Filter by names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, name?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<DtoListCategoriesResponse> {
            return localVarFp.categoriesGet(limit, offset, status, sort, order, slug, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft delete a category
         * @summary Delete a category
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.categoriesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a category by its ID
         * @summary Get category by ID
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoCategoryResponse> {
            return localVarFp.categoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing category
         * @summary Update a category
         * @param {string} id Category ID
         * @param {DtoUpdateCategoryRequest} request Update category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesIdPut(id: string, request: DtoUpdateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoCategoryResponse> {
            return localVarFp.categoriesIdPut(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new category with the provided details
         * @summary Create a new category
         * @param {DtoCreateCategoryRequest} request Create category request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPost(request: DtoCreateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoCategoryResponse> {
            return localVarFp.categoriesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a category by its slug
         * @summary Get category by slug
         * @param {string} slug Category slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoCategoryResponse> {
            return localVarFp.categoriesSlugSlugGet(slug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * Get a paginated list of categories with filtering and pagination
     * @summary List categories
     * @param {number} [limit] Limit
     * @param {number} [offset] Offset
     * @param {string} [status] Status
     * @param {string} [sort] Sort field
     * @param {string} [order] Sort order (asc/desc)
     * @param {Array<string>} [slug] Filter by slugs
     * @param {Array<string>} [name] Filter by names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, name?: Array<string>, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesGet(limit, offset, status, sort, order, slug, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft delete a category
     * @summary Delete a category
     * @param {string} id Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a category by its ID
     * @summary Get category by ID
     * @param {string} id Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing category
     * @summary Update a category
     * @param {string} id Category ID
     * @param {DtoUpdateCategoryRequest} request Update category request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesIdPut(id: string, request: DtoUpdateCategoryRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesIdPut(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new category with the provided details
     * @summary Create a new category
     * @param {DtoCreateCategoryRequest} request Create category request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesPost(request: DtoCreateCategoryRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a category by its slug
     * @summary Get category by slug
     * @param {string} slug Category slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoriesSlugSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all occurrences for a specific event
         * @summary List occurrences for event
         * @param {string} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsEventIdOccurrencesGet: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventsEventIdOccurrencesGet', 'eventId', eventId)
            const localVarPath = `/events/{eventId}/occurrences`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of events with filtering and pagination. Use expand=true with from_date and to_date to get expanded occurrences.
         * @summary List events
         * @param {boolean} [expand] If true, expand occurrences in date range
         * @param {string} [fromDate] ISO date YYYY-MM-DD
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {EventsGetOrderEnum} [order] 
         * @param {string} [placeId] 
         * @param {string} [sort] 
         * @param {EventsGetStatusEnum} [status] 
         * @param {Array<string>} [tags] 
         * @param {string} [toDate] ISO date YYYY-MM-DD
         * @param {EventsGetTypeEnum} [type] 
         * @param {boolean} [expand2] Expand occurrences in date range
         * @param {string} [fromDate2] Start date for expansion (YYYY-MM-DD)
         * @param {string} [toDate2] End date for expansion (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet: async (expand?: boolean, fromDate?: string, limit?: number, offset?: number, order?: EventsGetOrderEnum, placeId?: string, sort?: string, status?: EventsGetStatusEnum, tags?: Array<string>, toDate?: string, type?: EventsGetTypeEnum, expand2?: boolean, fromDate2?: string, toDate2?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (placeId !== undefined) {
                localVarQueryParameter['place_id'] = placeId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (expand2 !== undefined) {
                localVarQueryParameter['expand'] = expand2;
            }

            if (fromDate2 !== undefined) {
                localVarQueryParameter['from_date'] = fromDate2;
            }

            if (toDate2 !== undefined) {
                localVarQueryParameter['to_date'] = toDate2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft delete an event
         * @summary Delete an event
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsIdDelete', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an event by its ID
         * @summary Get event by ID
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsIdGet', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Increment the interested count for an event (user marked as interested)
         * @summary Increment event interested count
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdInterestedPost: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsIdInterestedPost', 'id', id)
            const localVarPath = `/events/{id}/interested`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing event
         * @summary Update an event
         * @param {string} id Event ID
         * @param {DtoUpdateEventRequest} request Update event request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPut: async (id: string, request: DtoUpdateEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsIdPut', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('eventsIdPut', 'request', request)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Increment the view count for an event (analytics)
         * @summary Increment event view count
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdViewPost: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsIdViewPost', 'id', id)
            const localVarPath = `/events/{id}/view`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft delete an event occurrence
         * @summary Delete occurrence
         * @param {string} id Occurrence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsOccurrencesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsOccurrencesIdDelete', 'id', id)
            const localVarPath = `/events/occurrences/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an event occurrence by its ID
         * @summary Get occurrence by ID
         * @param {string} id Occurrence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsOccurrencesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsOccurrencesIdGet', 'id', id)
            const localVarPath = `/events/occurrences/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing event occurrence
         * @summary Update occurrence
         * @param {string} id Occurrence ID
         * @param {DtoUpdateOccurrenceRequest} request Update occurrence request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsOccurrencesIdPut: async (id: string, request: DtoUpdateOccurrenceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsOccurrencesIdPut', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('eventsOccurrencesIdPut', 'request', request)
            const localVarPath = `/events/occurrences/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new occurrence for an event
         * @summary Create event occurrence
         * @param {DtoCreateOccurrenceRequest} request Create occurrence request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsOccurrencesPost: async (request: DtoCreateOccurrenceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('eventsOccurrencesPost', 'request', request)
            const localVarPath = `/events/occurrences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new event with the provided details
         * @summary Create a new event
         * @param {DtoCreateEventRequest} request Create event request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPost: async (request: DtoCreateEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('eventsPost', 'request', request)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an event by its slug
         * @summary Get event by slug
         * @param {string} slug Event slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsSlugSlugGet: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('eventsSlugSlugGet', 'slug', slug)
            const localVarPath = `/events/slug/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all occurrences for a specific event
         * @summary List occurrences for event
         * @param {string} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsEventIdOccurrencesGet(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DtoOccurrenceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsEventIdOccurrencesGet(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsEventIdOccurrencesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a paginated list of events with filtering and pagination. Use expand=true with from_date and to_date to get expanded occurrences.
         * @summary List events
         * @param {boolean} [expand] If true, expand occurrences in date range
         * @param {string} [fromDate] ISO date YYYY-MM-DD
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {EventsGetOrderEnum} [order] 
         * @param {string} [placeId] 
         * @param {string} [sort] 
         * @param {EventsGetStatusEnum} [status] 
         * @param {Array<string>} [tags] 
         * @param {string} [toDate] ISO date YYYY-MM-DD
         * @param {EventsGetTypeEnum} [type] 
         * @param {boolean} [expand2] Expand occurrences in date range
         * @param {string} [fromDate2] Start date for expansion (YYYY-MM-DD)
         * @param {string} [toDate2] End date for expansion (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsGet(expand?: boolean, fromDate?: string, limit?: number, offset?: number, order?: EventsGetOrderEnum, placeId?: string, sort?: string, status?: EventsGetStatusEnum, tags?: Array<string>, toDate?: string, type?: EventsGetTypeEnum, expand2?: boolean, fromDate2?: string, toDate2?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoListEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsGet(expand, fromDate, limit, offset, order, placeId, sort, status, tags, toDate, type, expand2, fromDate2, toDate2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft delete an event
         * @summary Delete an event
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an event by its ID
         * @summary Get event by ID
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Increment the interested count for an event (user marked as interested)
         * @summary Increment event interested count
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsIdInterestedPost(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsIdInterestedPost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsIdInterestedPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing event
         * @summary Update an event
         * @param {string} id Event ID
         * @param {DtoUpdateEventRequest} request Update event request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsIdPut(id: string, request: DtoUpdateEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsIdPut(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Increment the view count for an event (analytics)
         * @summary Increment event view count
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsIdViewPost(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsIdViewPost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsIdViewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft delete an event occurrence
         * @summary Delete occurrence
         * @param {string} id Occurrence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsOccurrencesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsOccurrencesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsOccurrencesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an event occurrence by its ID
         * @summary Get occurrence by ID
         * @param {string} id Occurrence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsOccurrencesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoOccurrenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsOccurrencesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsOccurrencesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing event occurrence
         * @summary Update occurrence
         * @param {string} id Occurrence ID
         * @param {DtoUpdateOccurrenceRequest} request Update occurrence request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsOccurrencesIdPut(id: string, request: DtoUpdateOccurrenceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoOccurrenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsOccurrencesIdPut(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsOccurrencesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new occurrence for an event
         * @summary Create event occurrence
         * @param {DtoCreateOccurrenceRequest} request Create occurrence request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsOccurrencesPost(request: DtoCreateOccurrenceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoOccurrenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsOccurrencesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsOccurrencesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new event with the provided details
         * @summary Create a new event
         * @param {DtoCreateEventRequest} request Create event request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsPost(request: DtoCreateEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an event by its slug
         * @summary Get event by slug
         * @param {string} slug Event slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsSlugSlugGet(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventsSlugSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * Get all occurrences for a specific event
         * @summary List occurrences for event
         * @param {string} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsEventIdOccurrencesGet(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DtoOccurrenceResponse>> {
            return localVarFp.eventsEventIdOccurrencesGet(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated list of events with filtering and pagination. Use expand=true with from_date and to_date to get expanded occurrences.
         * @summary List events
         * @param {boolean} [expand] If true, expand occurrences in date range
         * @param {string} [fromDate] ISO date YYYY-MM-DD
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {EventsGetOrderEnum} [order] 
         * @param {string} [placeId] 
         * @param {string} [sort] 
         * @param {EventsGetStatusEnum} [status] 
         * @param {Array<string>} [tags] 
         * @param {string} [toDate] ISO date YYYY-MM-DD
         * @param {EventsGetTypeEnum} [type] 
         * @param {boolean} [expand2] Expand occurrences in date range
         * @param {string} [fromDate2] Start date for expansion (YYYY-MM-DD)
         * @param {string} [toDate2] End date for expansion (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet(expand?: boolean, fromDate?: string, limit?: number, offset?: number, order?: EventsGetOrderEnum, placeId?: string, sort?: string, status?: EventsGetStatusEnum, tags?: Array<string>, toDate?: string, type?: EventsGetTypeEnum, expand2?: boolean, fromDate2?: string, toDate2?: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoListEventsResponse> {
            return localVarFp.eventsGet(expand, fromDate, limit, offset, order, placeId, sort, status, tags, toDate, type, expand2, fromDate2, toDate2, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft delete an event
         * @summary Delete an event
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.eventsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an event by its ID
         * @summary Get event by ID
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoEventResponse> {
            return localVarFp.eventsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Increment the interested count for an event (user marked as interested)
         * @summary Increment event interested count
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdInterestedPost(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.eventsIdInterestedPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing event
         * @summary Update an event
         * @param {string} id Event ID
         * @param {DtoUpdateEventRequest} request Update event request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPut(id: string, request: DtoUpdateEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoEventResponse> {
            return localVarFp.eventsIdPut(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Increment the view count for an event (analytics)
         * @summary Increment event view count
         * @param {string} id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdViewPost(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.eventsIdViewPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft delete an event occurrence
         * @summary Delete occurrence
         * @param {string} id Occurrence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsOccurrencesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.eventsOccurrencesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an event occurrence by its ID
         * @summary Get occurrence by ID
         * @param {string} id Occurrence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsOccurrencesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoOccurrenceResponse> {
            return localVarFp.eventsOccurrencesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing event occurrence
         * @summary Update occurrence
         * @param {string} id Occurrence ID
         * @param {DtoUpdateOccurrenceRequest} request Update occurrence request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsOccurrencesIdPut(id: string, request: DtoUpdateOccurrenceRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoOccurrenceResponse> {
            return localVarFp.eventsOccurrencesIdPut(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new occurrence for an event
         * @summary Create event occurrence
         * @param {DtoCreateOccurrenceRequest} request Create occurrence request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsOccurrencesPost(request: DtoCreateOccurrenceRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoOccurrenceResponse> {
            return localVarFp.eventsOccurrencesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new event with the provided details
         * @summary Create a new event
         * @param {DtoCreateEventRequest} request Create event request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPost(request: DtoCreateEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoEventResponse> {
            return localVarFp.eventsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an event by its slug
         * @summary Get event by slug
         * @param {string} slug Event slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoEventResponse> {
            return localVarFp.eventsSlugSlugGet(slug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * Get all occurrences for a specific event
     * @summary List occurrences for event
     * @param {string} eventId Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsEventIdOccurrencesGet(eventId: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsEventIdOccurrencesGet(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a paginated list of events with filtering and pagination. Use expand=true with from_date and to_date to get expanded occurrences.
     * @summary List events
     * @param {boolean} [expand] If true, expand occurrences in date range
     * @param {string} [fromDate] ISO date YYYY-MM-DD
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {EventsGetOrderEnum} [order] 
     * @param {string} [placeId] 
     * @param {string} [sort] 
     * @param {EventsGetStatusEnum} [status] 
     * @param {Array<string>} [tags] 
     * @param {string} [toDate] ISO date YYYY-MM-DD
     * @param {EventsGetTypeEnum} [type] 
     * @param {boolean} [expand2] Expand occurrences in date range
     * @param {string} [fromDate2] Start date for expansion (YYYY-MM-DD)
     * @param {string} [toDate2] End date for expansion (YYYY-MM-DD)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsGet(expand?: boolean, fromDate?: string, limit?: number, offset?: number, order?: EventsGetOrderEnum, placeId?: string, sort?: string, status?: EventsGetStatusEnum, tags?: Array<string>, toDate?: string, type?: EventsGetTypeEnum, expand2?: boolean, fromDate2?: string, toDate2?: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsGet(expand, fromDate, limit, offset, order, placeId, sort, status, tags, toDate, type, expand2, fromDate2, toDate2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft delete an event
     * @summary Delete an event
     * @param {string} id Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an event by its ID
     * @summary Get event by ID
     * @param {string} id Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Increment the interested count for an event (user marked as interested)
     * @summary Increment event interested count
     * @param {string} id Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsIdInterestedPost(id: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsIdInterestedPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing event
     * @summary Update an event
     * @param {string} id Event ID
     * @param {DtoUpdateEventRequest} request Update event request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsIdPut(id: string, request: DtoUpdateEventRequest, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsIdPut(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Increment the view count for an event (analytics)
     * @summary Increment event view count
     * @param {string} id Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsIdViewPost(id: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsIdViewPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft delete an event occurrence
     * @summary Delete occurrence
     * @param {string} id Occurrence ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsOccurrencesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsOccurrencesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an event occurrence by its ID
     * @summary Get occurrence by ID
     * @param {string} id Occurrence ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsOccurrencesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsOccurrencesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing event occurrence
     * @summary Update occurrence
     * @param {string} id Occurrence ID
     * @param {DtoUpdateOccurrenceRequest} request Update occurrence request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsOccurrencesIdPut(id: string, request: DtoUpdateOccurrenceRequest, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsOccurrencesIdPut(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new occurrence for an event
     * @summary Create event occurrence
     * @param {DtoCreateOccurrenceRequest} request Create occurrence request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsOccurrencesPost(request: DtoCreateOccurrenceRequest, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsOccurrencesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new event with the provided details
     * @summary Create a new event
     * @param {DtoCreateEventRequest} request Create event request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsPost(request: DtoCreateEventRequest, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an event by its slug
     * @summary Get event by slug
     * @param {string} slug Event slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsSlugSlugGet(slug: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsSlugSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EventsGetOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type EventsGetOrderEnum = typeof EventsGetOrderEnum[keyof typeof EventsGetOrderEnum];
/**
 * @export
 */
export const EventsGetStatusEnum = {
    StatusPublished: 'published',
    StatusDeleted: 'deleted',
    StatusArchived: 'archived',
    StatusInactive: 'inactive',
    StatusPending: 'pending',
    StatusDraft: 'draft'
} as const;
export type EventsGetStatusEnum = typeof EventsGetStatusEnum[keyof typeof EventsGetStatusEnum];
/**
 * @export
 */
export const EventsGetTypeEnum = {
    EventTypeAarti: 'AARTI',
    EventTypeFestival: 'FESTIVAL',
    EventTypeCultural: 'CULTURAL',
    EventTypeWorkshop: 'WORKSHOP',
    EventTypeSpecialDarshan: 'SPECIAL_DARSHAN'
} as const;
export type EventsGetTypeEnum = typeof EventsGetTypeEnum[keyof typeof EventsGetTypeEnum];


/**
 * HotelApi - axios parameter creator
 * @export
 */
export const HotelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a paginated list of hotels with filtering and pagination
         * @summary List hotels
         * @param {string} [endTime] 
         * @param {string} [expand] 
         * @param {string} [lastViewedAfter] Trending filter
         * @param {number} [latitude] Geospatial filters
         * @param {number} [limit] 
         * @param {number} [longitude] 
         * @param {number} [maxPrice] 
         * @param {number} [minPrice] Price range filters
         * @param {number} [offset] 
         * @param {HotelsGetOrderEnum} [order] 
         * @param {number} [radiusM] radius in meters
         * @param {string} [searchQuery] Search
         * @param {Array<string>} [slug] Custom filters
         * @param {string} [sort] 
         * @param {Array<number>} [starRating] 
         * @param {string} [startTime] 
         * @param {HotelsGetStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsGet: async (endTime?: string, expand?: string, lastViewedAfter?: string, latitude?: number, limit?: number, longitude?: number, maxPrice?: number, minPrice?: number, offset?: number, order?: HotelsGetOrderEnum, radiusM?: number, searchQuery?: string, slug?: Array<string>, sort?: string, starRating?: Array<number>, startTime?: string, status?: HotelsGetStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hotels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (lastViewedAfter !== undefined) {
                localVarQueryParameter['last_viewed_after'] = lastViewedAfter;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (maxPrice !== undefined) {
                localVarQueryParameter['max_price'] = maxPrice;
            }

            if (minPrice !== undefined) {
                localVarQueryParameter['min_price'] = minPrice;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (radiusM !== undefined) {
                localVarQueryParameter['radius_m'] = radiusM;
            }

            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }

            if (slug) {
                localVarQueryParameter['slug'] = slug.join(COLLECTION_FORMATS.csv);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (starRating) {
                localVarQueryParameter['star_rating'] = starRating.join(COLLECTION_FORMATS.csv);
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft delete a hotel
         * @summary Delete a hotel
         * @param {string} id Hotel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('hotelsIdDelete', 'id', id)
            const localVarPath = `/hotels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a hotel by its ID
         * @summary Get hotel by ID
         * @param {string} id Hotel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('hotelsIdGet', 'id', id)
            const localVarPath = `/hotels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing hotel
         * @summary Update a hotel
         * @param {string} id Hotel ID
         * @param {DtoUpdateHotelRequest} request Update hotel request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsIdPut: async (id: string, request: DtoUpdateHotelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('hotelsIdPut', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('hotelsIdPut', 'request', request)
            const localVarPath = `/hotels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new hotel with the provided details
         * @summary Create a new hotel
         * @param {DtoCreateHotelRequest} request Create hotel request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsPost: async (request: DtoCreateHotelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('hotelsPost', 'request', request)
            const localVarPath = `/hotels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a hotel by its slug
         * @summary Get hotel by slug
         * @param {string} slug Hotel slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsSlugSlugGet: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('hotelsSlugSlugGet', 'slug', slug)
            const localVarPath = `/hotels/slug/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HotelApi - functional programming interface
 * @export
 */
export const HotelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HotelApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a paginated list of hotels with filtering and pagination
         * @summary List hotels
         * @param {string} [endTime] 
         * @param {string} [expand] 
         * @param {string} [lastViewedAfter] Trending filter
         * @param {number} [latitude] Geospatial filters
         * @param {number} [limit] 
         * @param {number} [longitude] 
         * @param {number} [maxPrice] 
         * @param {number} [minPrice] Price range filters
         * @param {number} [offset] 
         * @param {HotelsGetOrderEnum} [order] 
         * @param {number} [radiusM] radius in meters
         * @param {string} [searchQuery] Search
         * @param {Array<string>} [slug] Custom filters
         * @param {string} [sort] 
         * @param {Array<number>} [starRating] 
         * @param {string} [startTime] 
         * @param {HotelsGetStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hotelsGet(endTime?: string, expand?: string, lastViewedAfter?: string, latitude?: number, limit?: number, longitude?: number, maxPrice?: number, minPrice?: number, offset?: number, order?: HotelsGetOrderEnum, radiusM?: number, searchQuery?: string, slug?: Array<string>, sort?: string, starRating?: Array<number>, startTime?: string, status?: HotelsGetStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoListHotelsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hotelsGet(endTime, expand, lastViewedAfter, latitude, limit, longitude, maxPrice, minPrice, offset, order, radiusM, searchQuery, slug, sort, starRating, startTime, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HotelApi.hotelsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft delete a hotel
         * @summary Delete a hotel
         * @param {string} id Hotel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hotelsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hotelsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HotelApi.hotelsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a hotel by its ID
         * @summary Get hotel by ID
         * @param {string} id Hotel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hotelsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoHotelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hotelsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HotelApi.hotelsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing hotel
         * @summary Update a hotel
         * @param {string} id Hotel ID
         * @param {DtoUpdateHotelRequest} request Update hotel request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hotelsIdPut(id: string, request: DtoUpdateHotelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoHotelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hotelsIdPut(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HotelApi.hotelsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new hotel with the provided details
         * @summary Create a new hotel
         * @param {DtoCreateHotelRequest} request Create hotel request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hotelsPost(request: DtoCreateHotelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoHotelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hotelsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HotelApi.hotelsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a hotel by its slug
         * @summary Get hotel by slug
         * @param {string} slug Hotel slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hotelsSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoHotelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hotelsSlugSlugGet(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HotelApi.hotelsSlugSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HotelApi - factory interface
 * @export
 */
export const HotelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HotelApiFp(configuration)
    return {
        /**
         * Get a paginated list of hotels with filtering and pagination
         * @summary List hotels
         * @param {string} [endTime] 
         * @param {string} [expand] 
         * @param {string} [lastViewedAfter] Trending filter
         * @param {number} [latitude] Geospatial filters
         * @param {number} [limit] 
         * @param {number} [longitude] 
         * @param {number} [maxPrice] 
         * @param {number} [minPrice] Price range filters
         * @param {number} [offset] 
         * @param {HotelsGetOrderEnum} [order] 
         * @param {number} [radiusM] radius in meters
         * @param {string} [searchQuery] Search
         * @param {Array<string>} [slug] Custom filters
         * @param {string} [sort] 
         * @param {Array<number>} [starRating] 
         * @param {string} [startTime] 
         * @param {HotelsGetStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsGet(endTime?: string, expand?: string, lastViewedAfter?: string, latitude?: number, limit?: number, longitude?: number, maxPrice?: number, minPrice?: number, offset?: number, order?: HotelsGetOrderEnum, radiusM?: number, searchQuery?: string, slug?: Array<string>, sort?: string, starRating?: Array<number>, startTime?: string, status?: HotelsGetStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<DtoListHotelsResponse> {
            return localVarFp.hotelsGet(endTime, expand, lastViewedAfter, latitude, limit, longitude, maxPrice, minPrice, offset, order, radiusM, searchQuery, slug, sort, starRating, startTime, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft delete a hotel
         * @summary Delete a hotel
         * @param {string} id Hotel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.hotelsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a hotel by its ID
         * @summary Get hotel by ID
         * @param {string} id Hotel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoHotelResponse> {
            return localVarFp.hotelsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing hotel
         * @summary Update a hotel
         * @param {string} id Hotel ID
         * @param {DtoUpdateHotelRequest} request Update hotel request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsIdPut(id: string, request: DtoUpdateHotelRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoHotelResponse> {
            return localVarFp.hotelsIdPut(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new hotel with the provided details
         * @summary Create a new hotel
         * @param {DtoCreateHotelRequest} request Create hotel request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsPost(request: DtoCreateHotelRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoHotelResponse> {
            return localVarFp.hotelsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a hotel by its slug
         * @summary Get hotel by slug
         * @param {string} slug Hotel slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelsSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoHotelResponse> {
            return localVarFp.hotelsSlugSlugGet(slug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HotelApi - object-oriented interface
 * @export
 * @class HotelApi
 * @extends {BaseAPI}
 */
export class HotelApi extends BaseAPI {
    /**
     * Get a paginated list of hotels with filtering and pagination
     * @summary List hotels
     * @param {string} [endTime] 
     * @param {string} [expand] 
     * @param {string} [lastViewedAfter] Trending filter
     * @param {number} [latitude] Geospatial filters
     * @param {number} [limit] 
     * @param {number} [longitude] 
     * @param {number} [maxPrice] 
     * @param {number} [minPrice] Price range filters
     * @param {number} [offset] 
     * @param {HotelsGetOrderEnum} [order] 
     * @param {number} [radiusM] radius in meters
     * @param {string} [searchQuery] Search
     * @param {Array<string>} [slug] Custom filters
     * @param {string} [sort] 
     * @param {Array<number>} [starRating] 
     * @param {string} [startTime] 
     * @param {HotelsGetStatusEnum} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotelApi
     */
    public hotelsGet(endTime?: string, expand?: string, lastViewedAfter?: string, latitude?: number, limit?: number, longitude?: number, maxPrice?: number, minPrice?: number, offset?: number, order?: HotelsGetOrderEnum, radiusM?: number, searchQuery?: string, slug?: Array<string>, sort?: string, starRating?: Array<number>, startTime?: string, status?: HotelsGetStatusEnum, options?: RawAxiosRequestConfig) {
        return HotelApiFp(this.configuration).hotelsGet(endTime, expand, lastViewedAfter, latitude, limit, longitude, maxPrice, minPrice, offset, order, radiusM, searchQuery, slug, sort, starRating, startTime, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft delete a hotel
     * @summary Delete a hotel
     * @param {string} id Hotel ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotelApi
     */
    public hotelsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return HotelApiFp(this.configuration).hotelsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a hotel by its ID
     * @summary Get hotel by ID
     * @param {string} id Hotel ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotelApi
     */
    public hotelsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return HotelApiFp(this.configuration).hotelsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing hotel
     * @summary Update a hotel
     * @param {string} id Hotel ID
     * @param {DtoUpdateHotelRequest} request Update hotel request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotelApi
     */
    public hotelsIdPut(id: string, request: DtoUpdateHotelRequest, options?: RawAxiosRequestConfig) {
        return HotelApiFp(this.configuration).hotelsIdPut(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new hotel with the provided details
     * @summary Create a new hotel
     * @param {DtoCreateHotelRequest} request Create hotel request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotelApi
     */
    public hotelsPost(request: DtoCreateHotelRequest, options?: RawAxiosRequestConfig) {
        return HotelApiFp(this.configuration).hotelsPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a hotel by its slug
     * @summary Get hotel by slug
     * @param {string} slug Hotel slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotelApi
     */
    public hotelsSlugSlugGet(slug: string, options?: RawAxiosRequestConfig) {
        return HotelApiFp(this.configuration).hotelsSlugSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const HotelsGetOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type HotelsGetOrderEnum = typeof HotelsGetOrderEnum[keyof typeof HotelsGetOrderEnum];
/**
 * @export
 */
export const HotelsGetStatusEnum = {
    StatusPublished: 'published',
    StatusDeleted: 'deleted',
    StatusArchived: 'archived',
    StatusInactive: 'inactive',
    StatusPending: 'pending',
    StatusDraft: 'draft'
} as const;
export type HotelsGetStatusEnum = typeof HotelsGetStatusEnum[keyof typeof HotelsGetStatusEnum];


/**
 * PlaceApi - axios parameter creator
 * @export
 */
export const PlaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get feed data with multiple sections (trending, popular, latest, nearby)
         * @summary Get feed data
         * @param {DtoFeedRequest} request Feed request with sections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedPost: async (request: DtoFeedRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('feedPost', 'request', request)
            const localVarPath = `/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of places with filtering and pagination
         * @summary List places
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [placeTypes] Filter by place types
         * @param {Array<string>} [categories] Filter by categories
         * @param {Array<string>} [amenities] Filter by amenities
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {number} [latitude] Latitude for geospatial filtering
         * @param {number} [longitude] Longitude for geospatial filtering
         * @param {number} [radiusKm] Radius in kilometers for geospatial filtering
         * @param {string} [searchQuery] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesGet: async (limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, placeTypes?: Array<string>, categories?: Array<string>, amenities?: Array<string>, minRating?: number, maxRating?: number, latitude?: number, longitude?: number, radiusKm?: number, searchQuery?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (slug) {
                localVarQueryParameter['slug'] = slug.join(COLLECTION_FORMATS.csv);
            }

            if (placeTypes) {
                localVarQueryParameter['place_types'] = placeTypes.join(COLLECTION_FORMATS.csv);
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories.join(COLLECTION_FORMATS.csv);
            }

            if (amenities) {
                localVarQueryParameter['amenities'] = amenities.join(COLLECTION_FORMATS.csv);
            }

            if (minRating !== undefined) {
                localVarQueryParameter['min_rating'] = minRating;
            }

            if (maxRating !== undefined) {
                localVarQueryParameter['max_rating'] = maxRating;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (radiusKm !== undefined) {
                localVarQueryParameter['radius_km'] = radiusKm;
            }

            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft delete a place
         * @summary Delete a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdDelete', 'id', id)
            const localVarPath = `/places/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a place by its ID
         * @summary Get place by ID
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdGet', 'id', id)
            const localVarPath = `/places/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all images for a place
         * @summary Get place images
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdImagesGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdImagesGet', 'id', id)
            const localVarPath = `/places/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an image to a place
         * @summary Add image to place
         * @param {string} id Place ID
         * @param {DtoCreatePlaceImageRequest} request Create place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdImagesPost: async (id: string, request: DtoCreatePlaceImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdImagesPost', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('placesIdImagesPost', 'request', request)
            const localVarPath = `/places/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing place
         * @summary Update a place
         * @param {string} id Place ID
         * @param {DtoUpdatePlaceRequest} request Update place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdPut: async (id: string, request: DtoUpdatePlaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdPut', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('placesIdPut', 'request', request)
            const localVarPath = `/places/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Increment the view count for a specific place
         * @summary Increment view count for a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdViewPost: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placesIdViewPost', 'id', id)
            const localVarPath = `/places/{id}/view`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a place image
         * @summary Delete place image
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesImagesImageIdDelete: async (imageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('placesImagesImageIdDelete', 'imageId', imageId)
            const localVarPath = `/places/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing place image
         * @summary Update place image
         * @param {string} imageId Image ID
         * @param {DtoUpdatePlaceImageRequest} request Update place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesImagesImageIdPut: async (imageId: string, request: DtoUpdatePlaceImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('placesImagesImageIdPut', 'imageId', imageId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('placesImagesImageIdPut', 'request', request)
            const localVarPath = `/places/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new place with the provided details
         * @summary Create a new place
         * @param {DtoCreatePlaceRequest} request Create place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesPost: async (request: DtoCreatePlaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('placesPost', 'request', request)
            const localVarPath = `/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a place by its slug
         * @summary Get place by slug
         * @param {string} slug Place slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesSlugSlugGet: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('placesSlugSlugGet', 'slug', slug)
            const localVarPath = `/places/slug/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaceApi - functional programming interface
 * @export
 */
export const PlaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get feed data with multiple sections (trending, popular, latest, nearby)
         * @summary Get feed data
         * @param {DtoFeedRequest} request Feed request with sections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedPost(request: DtoFeedRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoFeedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.feedPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a paginated list of places with filtering and pagination
         * @summary List places
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [placeTypes] Filter by place types
         * @param {Array<string>} [categories] Filter by categories
         * @param {Array<string>} [amenities] Filter by amenities
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {number} [latitude] Latitude for geospatial filtering
         * @param {number} [longitude] Longitude for geospatial filtering
         * @param {number} [radiusKm] Radius in kilometers for geospatial filtering
         * @param {string} [searchQuery] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, placeTypes?: Array<string>, categories?: Array<string>, amenities?: Array<string>, minRating?: number, maxRating?: number, latitude?: number, longitude?: number, radiusKm?: number, searchQuery?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoListPlacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesGet(limit, offset, status, sort, order, slug, placeTypes, categories, amenities, minRating, maxRating, latitude, longitude, radiusKm, searchQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft delete a place
         * @summary Delete a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a place by its ID
         * @summary Get place by ID
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all images for a place
         * @summary Get place images
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdImagesGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DtoPlaceImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdImagesGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesIdImagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add an image to a place
         * @summary Add image to place
         * @param {string} id Place ID
         * @param {DtoCreatePlaceImageRequest} request Create place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdImagesPost(id: string, request: DtoCreatePlaceImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdImagesPost(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesIdImagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing place
         * @summary Update a place
         * @param {string} id Place ID
         * @param {DtoUpdatePlaceRequest} request Update place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdPut(id: string, request: DtoUpdatePlaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdPut(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Increment the view count for a specific place
         * @summary Increment view count for a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesIdViewPost(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdViewPost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesIdViewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a place image
         * @summary Delete place image
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesImagesImageIdDelete(imageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesImagesImageIdDelete(imageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesImagesImageIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing place image
         * @summary Update place image
         * @param {string} imageId Image ID
         * @param {DtoUpdatePlaceImageRequest} request Update place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesImagesImageIdPut(imageId: string, request: DtoUpdatePlaceImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesImagesImageIdPut(imageId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesImagesImageIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new place with the provided details
         * @summary Create a new place
         * @param {DtoCreatePlaceRequest} request Create place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesPost(request: DtoCreatePlaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a place by its slug
         * @summary Get place by slug
         * @param {string} slug Place slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoPlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placesSlugSlugGet(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaceApi.placesSlugSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlaceApi - factory interface
 * @export
 */
export const PlaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaceApiFp(configuration)
    return {
        /**
         * Get feed data with multiple sections (trending, popular, latest, nearby)
         * @summary Get feed data
         * @param {DtoFeedRequest} request Feed request with sections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedPost(request: DtoFeedRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoFeedResponse> {
            return localVarFp.feedPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated list of places with filtering and pagination
         * @summary List places
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [status] Status
         * @param {string} [sort] Sort field
         * @param {string} [order] Sort order (asc/desc)
         * @param {Array<string>} [slug] Filter by slugs
         * @param {Array<string>} [placeTypes] Filter by place types
         * @param {Array<string>} [categories] Filter by categories
         * @param {Array<string>} [amenities] Filter by amenities
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {number} [latitude] Latitude for geospatial filtering
         * @param {number} [longitude] Longitude for geospatial filtering
         * @param {number} [radiusKm] Radius in kilometers for geospatial filtering
         * @param {string} [searchQuery] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, placeTypes?: Array<string>, categories?: Array<string>, amenities?: Array<string>, minRating?: number, maxRating?: number, latitude?: number, longitude?: number, radiusKm?: number, searchQuery?: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoListPlacesResponse> {
            return localVarFp.placesGet(limit, offset, status, sort, order, slug, placeTypes, categories, amenities, minRating, maxRating, latitude, longitude, radiusKm, searchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft delete a place
         * @summary Delete a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.placesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a place by its ID
         * @summary Get place by ID
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceResponse> {
            return localVarFp.placesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all images for a place
         * @summary Get place images
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdImagesGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DtoPlaceImageResponse>> {
            return localVarFp.placesIdImagesGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an image to a place
         * @summary Add image to place
         * @param {string} id Place ID
         * @param {DtoCreatePlaceImageRequest} request Create place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdImagesPost(id: string, request: DtoCreatePlaceImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceImageResponse> {
            return localVarFp.placesIdImagesPost(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing place
         * @summary Update a place
         * @param {string} id Place ID
         * @param {DtoUpdatePlaceRequest} request Update place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdPut(id: string, request: DtoUpdatePlaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceResponse> {
            return localVarFp.placesIdPut(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Increment the view count for a specific place
         * @summary Increment view count for a place
         * @param {string} id Place ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesIdViewPost(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.placesIdViewPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a place image
         * @summary Delete place image
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesImagesImageIdDelete(imageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.placesImagesImageIdDelete(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing place image
         * @summary Update place image
         * @param {string} imageId Image ID
         * @param {DtoUpdatePlaceImageRequest} request Update place image request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesImagesImageIdPut(imageId: string, request: DtoUpdatePlaceImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceImageResponse> {
            return localVarFp.placesImagesImageIdPut(imageId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new place with the provided details
         * @summary Create a new place
         * @param {DtoCreatePlaceRequest} request Create place request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesPost(request: DtoCreatePlaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceResponse> {
            return localVarFp.placesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a place by its slug
         * @summary Get place by slug
         * @param {string} slug Place slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoPlaceResponse> {
            return localVarFp.placesSlugSlugGet(slug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaceApi - object-oriented interface
 * @export
 * @class PlaceApi
 * @extends {BaseAPI}
 */
export class PlaceApi extends BaseAPI {
    /**
     * Get feed data with multiple sections (trending, popular, latest, nearby)
     * @summary Get feed data
     * @param {DtoFeedRequest} request Feed request with sections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public feedPost(request: DtoFeedRequest, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).feedPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a paginated list of places with filtering and pagination
     * @summary List places
     * @param {number} [limit] Limit
     * @param {number} [offset] Offset
     * @param {string} [status] Status
     * @param {string} [sort] Sort field
     * @param {string} [order] Sort order (asc/desc)
     * @param {Array<string>} [slug] Filter by slugs
     * @param {Array<string>} [placeTypes] Filter by place types
     * @param {Array<string>} [categories] Filter by categories
     * @param {Array<string>} [amenities] Filter by amenities
     * @param {number} [minRating] Minimum rating
     * @param {number} [maxRating] Maximum rating
     * @param {number} [latitude] Latitude for geospatial filtering
     * @param {number} [longitude] Longitude for geospatial filtering
     * @param {number} [radiusKm] Radius in kilometers for geospatial filtering
     * @param {string} [searchQuery] Search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesGet(limit?: number, offset?: number, status?: string, sort?: string, order?: string, slug?: Array<string>, placeTypes?: Array<string>, categories?: Array<string>, amenities?: Array<string>, minRating?: number, maxRating?: number, latitude?: number, longitude?: number, radiusKm?: number, searchQuery?: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesGet(limit, offset, status, sort, order, slug, placeTypes, categories, amenities, minRating, maxRating, latitude, longitude, radiusKm, searchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft delete a place
     * @summary Delete a place
     * @param {string} id Place ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a place by its ID
     * @summary Get place by ID
     * @param {string} id Place ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all images for a place
     * @summary Get place images
     * @param {string} id Place ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesIdImagesGet(id: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesIdImagesGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an image to a place
     * @summary Add image to place
     * @param {string} id Place ID
     * @param {DtoCreatePlaceImageRequest} request Create place image request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesIdImagesPost(id: string, request: DtoCreatePlaceImageRequest, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesIdImagesPost(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing place
     * @summary Update a place
     * @param {string} id Place ID
     * @param {DtoUpdatePlaceRequest} request Update place request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesIdPut(id: string, request: DtoUpdatePlaceRequest, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesIdPut(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Increment the view count for a specific place
     * @summary Increment view count for a place
     * @param {string} id Place ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesIdViewPost(id: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesIdViewPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a place image
     * @summary Delete place image
     * @param {string} imageId Image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesImagesImageIdDelete(imageId: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesImagesImageIdDelete(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing place image
     * @summary Update place image
     * @param {string} imageId Image ID
     * @param {DtoUpdatePlaceImageRequest} request Update place image request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesImagesImageIdPut(imageId: string, request: DtoUpdatePlaceImageRequest, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesImagesImageIdPut(imageId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new place with the provided details
     * @summary Create a new place
     * @param {DtoCreatePlaceRequest} request Create place request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesPost(request: DtoCreatePlaceRequest, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a place by its slug
     * @summary Get place by slug
     * @param {string} slug Place slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public placesSlugSlugGet(slug: string, options?: RawAxiosRequestConfig) {
        return PlaceApiFp(this.configuration).placesSlugSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReviewsApi - axios parameter creator
 * @export
 */
export const ReviewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a paginated list of reviews with filtering
         * @summary List reviews
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [entityType] Entity type (place, experience, etc.)
         * @param {string} [entityId] Entity ID
         * @param {string} [userId] User ID
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsGet: async (limit?: number, offset?: number, entityType?: string, entityId?: string, userId?: string, minRating?: number, maxRating?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entity_type'] = entityType;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entity_id'] = entityId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (minRating !== undefined) {
                localVarQueryParameter['min_rating'] = minRating;
            }

            if (maxRating !== undefined) {
                localVarQueryParameter['max_rating'] = maxRating;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a review
         * @summary Delete a review
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reviewsIdDelete', 'id', id)
            const localVarPath = `/reviews/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a review by its ID
         * @summary Get review by ID
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reviewsIdGet', 'id', id)
            const localVarPath = `/reviews/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing review
         * @summary Update a review
         * @param {string} id Review ID
         * @param {DtoUpdateReviewRequest} request Update review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdPut: async (id: string, request: DtoUpdateReviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reviewsIdPut', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('reviewsIdPut', 'request', request)
            const localVarPath = `/reviews/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new review for a place or other entity
         * @summary Create a new review
         * @param {DtoCreateReviewRequest} request Create review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsPost: async (request: DtoCreateReviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('reviewsPost', 'request', request)
            const localVarPath = `/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get rating statistics for an entity (place, experience, etc.)
         * @summary Get rating statistics
         * @param {string} entityType Entity type (place, experience, etc.)
         * @param {string} entityId Entity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsStatsEntityTypeEntityIdGet: async (entityType: string, entityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('reviewsStatsEntityTypeEntityIdGet', 'entityType', entityType)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('reviewsStatsEntityTypeEntityIdGet', 'entityId', entityId)
            const localVarPath = `/reviews/stats/{entityType}/{entityId}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewsApi - functional programming interface
 * @export
 */
export const ReviewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a paginated list of reviews with filtering
         * @summary List reviews
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [entityType] Entity type (place, experience, etc.)
         * @param {string} [entityId] Entity ID
         * @param {string} [userId] User ID
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsGet(limit?: number, offset?: number, entityType?: string, entityId?: string, userId?: string, minRating?: number, maxRating?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesListResponseDtoReviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsGet(limit, offset, entityType, entityId, userId, minRating, maxRating, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a review
         * @summary Delete a review
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a review by its ID
         * @summary Get review by ID
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoReviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing review
         * @summary Update a review
         * @param {string} id Review ID
         * @param {DtoUpdateReviewRequest} request Update review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsIdPut(id: string, request: DtoUpdateReviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoReviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsIdPut(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new review for a place or other entity
         * @summary Create a new review
         * @param {DtoCreateReviewRequest} request Create review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsPost(request: DtoCreateReviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoReviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get rating statistics for an entity (place, experience, etc.)
         * @summary Get rating statistics
         * @param {string} entityType Entity type (place, experience, etc.)
         * @param {string} entityId Entity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsStatsEntityTypeEntityIdGet(entityType: string, entityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoRatingStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsStatsEntityTypeEntityIdGet(entityType, entityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.reviewsStatsEntityTypeEntityIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReviewsApi - factory interface
 * @export
 */
export const ReviewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewsApiFp(configuration)
    return {
        /**
         * Get a paginated list of reviews with filtering
         * @summary List reviews
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {string} [entityType] Entity type (place, experience, etc.)
         * @param {string} [entityId] Entity ID
         * @param {string} [userId] User ID
         * @param {number} [minRating] Minimum rating
         * @param {number} [maxRating] Maximum rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsGet(limit?: number, offset?: number, entityType?: string, entityId?: string, userId?: string, minRating?: number, maxRating?: number, options?: RawAxiosRequestConfig): AxiosPromise<TypesListResponseDtoReviewResponse> {
            return localVarFp.reviewsGet(limit, offset, entityType, entityId, userId, minRating, maxRating, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a review
         * @summary Delete a review
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.reviewsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a review by its ID
         * @summary Get review by ID
         * @param {string} id Review ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoReviewResponse> {
            return localVarFp.reviewsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing review
         * @summary Update a review
         * @param {string} id Review ID
         * @param {DtoUpdateReviewRequest} request Update review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsIdPut(id: string, request: DtoUpdateReviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoReviewResponse> {
            return localVarFp.reviewsIdPut(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new review for a place or other entity
         * @summary Create a new review
         * @param {DtoCreateReviewRequest} request Create review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsPost(request: DtoCreateReviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoReviewResponse> {
            return localVarFp.reviewsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get rating statistics for an entity (place, experience, etc.)
         * @summary Get rating statistics
         * @param {string} entityType Entity type (place, experience, etc.)
         * @param {string} entityId Entity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsStatsEntityTypeEntityIdGet(entityType: string, entityId: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoRatingStatsResponse> {
            return localVarFp.reviewsStatsEntityTypeEntityIdGet(entityType, entityId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReviewsApi - object-oriented interface
 * @export
 * @class ReviewsApi
 * @extends {BaseAPI}
 */
export class ReviewsApi extends BaseAPI {
    /**
     * Get a paginated list of reviews with filtering
     * @summary List reviews
     * @param {number} [limit] Limit
     * @param {number} [offset] Offset
     * @param {string} [entityType] Entity type (place, experience, etc.)
     * @param {string} [entityId] Entity ID
     * @param {string} [userId] User ID
     * @param {number} [minRating] Minimum rating
     * @param {number} [maxRating] Maximum rating
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsGet(limit?: number, offset?: number, entityType?: string, entityId?: string, userId?: string, minRating?: number, maxRating?: number, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsGet(limit, offset, entityType, entityId, userId, minRating, maxRating, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a review
     * @summary Delete a review
     * @param {string} id Review ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a review by its ID
     * @summary Get review by ID
     * @param {string} id Review ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing review
     * @summary Update a review
     * @param {string} id Review ID
     * @param {DtoUpdateReviewRequest} request Update review request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsIdPut(id: string, request: DtoUpdateReviewRequest, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsIdPut(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new review for a place or other entity
     * @summary Create a new review
     * @param {DtoCreateReviewRequest} request Create review request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsPost(request: DtoCreateReviewRequest, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get rating statistics for an entity (place, experience, etc.)
     * @summary Get rating statistics
     * @param {string} entityType Entity type (place, experience, etc.)
     * @param {string} entityId Entity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsStatsEntityTypeEntityIdGet(entityType: string, entityId: string, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsStatsEntityTypeEntityIdGet(entityType, entityId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the current user\'s information
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the current user\'s information
         * @summary Update current user
         * @param {DtoUpdateUserRequest} request Update user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPut: async (request: DtoUpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('userPut', 'request', request)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the current user\'s information
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoMeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the current user\'s information
         * @summary Update current user
         * @param {DtoUpdateUserRequest} request Update user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPut(request: DtoUpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoMeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPut(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Get the current user\'s information
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeGet(options?: RawAxiosRequestConfig): AxiosPromise<DtoMeResponse> {
            return localVarFp.userMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the current user\'s information
         * @summary Update current user
         * @param {DtoUpdateUserRequest} request Update user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPut(request: DtoUpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<DtoMeResponse> {
            return localVarFp.userPut(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Get the current user\'s information
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userMeGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the current user\'s information
     * @summary Update current user
     * @param {DtoUpdateUserRequest} request Update user request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPut(request: DtoUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userPut(request, options).then((request) => request(this.axios, this.basePath));
    }
}



